
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Summer Intensive 1 | Tighnari&#39;s blog</title>
    <meta name="author" content="Tighnari" />
    <meta name="description" content="总有人间一两风，圆我十万八千梦" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.css" />





<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TIGHNARI&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
        <a href="/friends">
            <i class="fa-solid fa-link fa-fw"></i>
            <span>&ensp;Friend_Links</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TIGHNARI&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
                <a href="/friends">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-link fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Friend_Links</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Summer Intensive 1</h1>
    </div>

    
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/7/4
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/study-notes/" style="color: #ff7d73">
                    study notes
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/summer-holiday/" style="color: #ffa2c4">
                    summer holiday
                </a>
            </span>
            
        </span>
        
    </div>
    
    <!-- 文章内容区域 - 修复加密逻辑 -->
    <div class="article-content">
        
            <!-- 非加密内容直接显示 -->
            <div class="content" v-pre>
                <h2 id="题单完成情况："><a href="#题单完成情况：" class="headerlink" title="题单完成情况："></a>题单完成情况：</h2><ul>
<li>2025.7.2  9&#x2F;11</li>
<li>2025.7.3  9&#x2F;15</li>
<li>2025.7.4  4&#x2F;4+2&#x2F;8</li>
<li>2025.7.5  10&#x2F;16</li>
<li>2025.7.6  5&#x2F;15 （这真的是需要写完的吗）</li>
<li>2025.7.7  1&#x2F;4+5&#x2F;9（一天两场模拟赛，懒得喷了）</li>
<li>2025.7.8  5&#x2F;14</li>
<li>2025.7.9  2&#x2F;12</li>
<li>2025.7.10  放假了！</li>
<li>2025.7.11  3&#x2F;4  1&#x2F;8（模拟赛，没看输出格式，光荣保龄）</li>
<li>2025.7.12  4&#x2F;8</li>
<li>2025.7.13  6&#x2F;9</li>
</ul>
<p>真的写不完啊！</p>
<span id="more"></span>

<h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>最终决定还是分成几段好一点，一个暑假写一起还是太长了。</p>
<p>2025.7.2-2025.7.5：实话说印象不深了，不知道摆烂的时候干了些啥了。</p>
<p>2025.7.6：下午课间打球，晚饭没吃打球，真打爽了。（为啥俩月没打羽毛球技术不降反增啊）</p>
<p>2025.7.7：上午模拟赛，中午打球，下午模拟赛，晚饭随便吃了点去打球。（已经懒得记录了，明天对我好一点）</p>
<p>2025.7.8：课间还被ban了，只能打 20 分钟了。</p>
<p>2025.7.9：今天下雨了，不打算打球了。<del>最终还是选择打球了</del></p>
<h2 id="2025-7-2"><a href="#2025-7-2" class="headerlink" title="2025.7.2"></a>2025.7.2</h2><p>STL+单调队列&#x2F;栈+并查集</p>
<p>STL讲了 set 和基于 set 实现的珂朵莉树。没有万众瞩目的 bitset &#96;(<em>&gt;﹏&lt;</em>)′</p>
<h3 id="珂朵莉树-模板-Problem-896C-Codeforces"><a href="#珂朵莉树-模板-Problem-896C-Codeforces" class="headerlink" title="珂朵莉树 [模板](Problem - 896C - Codeforces)"></a>珂朵莉树 [模板](<a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/896/C">Problem - 896C - Codeforces</a>)</h3><p>只有看完代码那一刻，才知道多么暴力……</p>
<p>复杂度依赖于区间推平，思路是将相同的值缩成一个点。</p>
<p>具体的，开一个结构体，形如：</p>
<pre><code class="cpp">struct node&#123;
    ll l,r;
    mutable ll v;
    node(ll l,ll r=0,ll v=0): l(l),r(r),v(v)&#123;&#125;
    bool operator &lt; (const node &amp;a) const&#123;
        return l&lt;a.l;
    &#125;
&#125;;
set&lt;node&gt; s;
</code></pre>
<p>最关键的就是分离操作，这应该也是珂朵莉树最有脑子的地方。</p>
<p>将我们需要的 $pos$ 位置的区间分成 $l,pos-1$ 与 $pos,r$</p>
<p>其实也不是很有脑啊。</p>
<pre><code class="cpp">auto split(int pos)&#123;
    auto it=s.lower_bound(node(pos));
    if(it!=s.end() &amp;&amp; it-&gt;l == pos) return it;
    it--;
    if(it-&gt;r &lt; pos) return s.end();
    ll l=it-&gt;l,r=it-&gt;r,v=it-&gt;;
    s.erase(it);
    s.insert(node(l,pos-1,v));
    return s.insert(node(pos,r,v)).first;
&#125;
</code></pre>
<p>注意：insert 的返回值是个 pair，第一个值是迭代器。</p>
<p>auto 大法好！</p>
<p>然后是珂朵莉树剩余的操作就是先拆出操作区间，然后暴力。</p>
<p>以推平操作为例：</p>
<pre><code class="cpp">void assign(ll l,ll r,ll x)&#123;
    auto itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,x));
&#125;
</code></pre>
<p>注意，此处要先进行 r+1 的split，再进行 l 的split。</p>
<p>不然会RE。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define p 1000000007
using namespace std;
const int N=1e5+10;
int n,m,seed,V,a[N];
int rnd()&#123;
    int res=seed;
    seed=(seed*7+13)%p;
    return res;
&#125;
struct node&#123;
    int l,r;//相同元素段的起终点
    mutable int v;//元素值
    node(int l,int r=0,int v=0):l(l),r(r),v(v)&#123;&#125;
    bool operator &lt; (const node &amp;a)const &#123;
        return l &lt; a.l;
    &#125;
&#125;;
set&lt;node&gt; s;
auto split(int pos)&#123;
    auto it=s.lower_bound(node(pos));
    if(it!=s.end() &amp;&amp; it-&gt;l==pos) return it;//如果恰好是 l
    it--;
    if(it-&gt;r &lt; pos) return s.end();//如果是最后一块
    int l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;
    s.erase(it);
    s.insert(node(l,pos-1,v));
    return s.insert(node(pos,r,v)).first;//insert的返回值是pair，第一位是迭代器
&#125;
//先计算 itr,不然会神秘 RE
void add(int l,int r,int x)&#123;
    auto itr=split(r+1),itl=split(l);
    for(auto it=itl;it!=itr;++it)&#123;
        it-&gt;v+=x;
    &#125;
&#125;
void assign(int l,int r,int x)&#123;
    auto itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,x));
&#125;
int qpow(int a,int b,int mod)&#123;
    int res=1;a%=mod;
    while(b)&#123;
        if(b&amp;1) res=res*a%mod;
        b&gt;&gt;=1;
        a=a*a%mod;
    &#125;
    return res;
&#125;
int calc(int l,int r,int x,int y)&#123;
    auto itr=split(r+1),itl=split(l);
    int ans=0;
    for(auto it=itl;it!=itr;++it)&#123;
        ans=(ans+qpow(it-&gt;v,x,y) * (it-&gt;r-it-&gt;l+1)%y)%y;
    &#125;
    return ans;
&#125;
struct Num&#123;
    int v,cnt;
    bool operator &lt; (const Num &amp;a)const&#123;
        return v&lt;a.v;
    &#125;
&#125;;
int rnk(int l,int r,int x)&#123;
    vector&lt;Num&gt; vec;
    auto itr=split(r+1),itl=split(l);
    for(auto it=itl;it!=itr;++it)&#123;
        vec.push_back(&#123;it-&gt;v,it-&gt;r-it-&gt;l+1&#125;);
    &#125;
    sort(vec.begin(),vec.end());
    int id;
    for(id=0;id&lt;(int)vec.size();id++)&#123;
        if(vec[id].cnt&lt;x) x-=vec[id].cnt;
        else break;
    &#125;
    return vec[id].v;
&#125;
signed main()&#123;
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;V;
    for(int i=1;i&lt;=n;i++)&#123;
        a[i]=(rnd()%V)+1;
        s.insert(node(i,i,a[i]));
    &#125;
    for(int i=1,op,l,r,x,y;i&lt;=m;i++)&#123;
        op=rnd()%4+1;
        l=rnd()%n+1,r=rnd()%n+1;
        if(l&gt;r) swap(l,r);
        if(op==3)&#123;
            x=(rnd()%(r-l+1))+1;
        &#125;else&#123;
            x=(rnd()%V)+1;
        &#125;
        if(op==4)&#123;
            y=rnd()%V+1;
        &#125;
        if(op==1)&#123;
            add(l,r,x);
        &#125;else if(op==2)&#123;
            assign(l,r,x);
        &#125;else if(op==3)&#123;
            cout &lt;&lt; rnk(l,r,x) &lt;&lt; &#39;\n&#39;;
        &#125;else&#123;
            cout &lt;&lt; calc(l,r,x,y) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="单调栈做最大子矩形-模板-P4147-玉蟾宫-洛谷"><a href="#单调栈做最大子矩形-模板-P4147-玉蟾宫-洛谷" class="headerlink" title="单调栈做最大子矩形 [模板](P4147 玉蟾宫 - 洛谷)"></a>单调栈做最大子矩形 [模板](<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4147">P4147 玉蟾宫 - 洛谷</a>)</h3><p>在每个点能向上延伸多少可以用前缀和。</p>
<p>单调栈维护一下每一个向上延伸的块最多延伸到哪里，然后再乘上长。</p>
<p>最后模拟即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N = 1e3+10;
int pos[N][N];
int n,m,ans;
struct node&#123;
    int len,hei;
&#125;sta[N];
void solve(int x)&#123;
    int top=0,len=0;
    for(int i=1;i&lt;=m;i++)&#123;
        len=0;
        while(sta[top].hei&gt;=pos[x][i] &amp;&amp; top&gt;0)&#123;
            len+=sta[top].len;
            ans=max(ans,sta[top--].hei*len);
        &#125;
        sta[++top].hei=pos[x][i];
        sta[top].len=len+1;
    &#125;
    len=0;
    while(top&gt;0)&#123;
        len+=sta[top].len;
        ans=max(ans,sta[top--].hei*len);
    &#125;
&#125;
signed main()&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=m;j++)&#123;
            char ch;cin&gt;&gt;ch;
            if(ch==&#39;R&#39;)&#123;
                pos[i][j]=0;
            &#125;else&#123;
                pos[i][j]=pos[i-1][j]+1;
            &#125;
        &#125;
    &#125;
    for(int i=1;i&lt;=n;i++) solve(i);
    cout &lt;&lt; 3*ans;
    return 0;
&#125;
</code></pre>
<h3 id="单调队列优化dp-瑰丽华尔兹-和-股票交易"><a href="#单调队列优化dp-瑰丽华尔兹-和-股票交易" class="headerlink" title="单调队列优化dp 瑰丽华尔兹 和 股票交易"></a>单调队列优化dp <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2254">瑰丽华尔兹</a> 和 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2569">股票交易</a></h3><p>单调队列优化的是区间最大最小值。（那我为什么不……）</p>
<p>假如 dp 方程形如：$f_i&#x3D;\max_{1\le k \le j}(f_k,a_k)+a_i$ 这类，​$\max$ 函数中不与 $i$ 有关的东西，都可以拿单调队列维护。</p>
<p>注意边界情况。</p>
<pre><code class="cpp">//股票交易
#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 2e3+10;
int T,P,W;
int ap[N],bp[N],as[N],bs[N];
int f[N][N],ans,l,r,que[N];
int main()&#123;
    cin&gt;&gt;T&gt;&gt;P&gt;&gt;W;
    for(int i=1;i&lt;=T;i++)&#123;
        cin&gt;&gt;ap[i]&gt;&gt;bp[i]&gt;&gt;as[i]&gt;&gt;bs[i];
    &#125;
    memset(f,128,sizeof(f));
    for(int i=1;i&lt;=T;i++)&#123;
        for(int j=0;j&lt;=as[i];j++)&#123;
            f[i][j]=-j*ap[i];
        &#125;
        for(int j=0;j&lt;=P;j++)&#123;
            f[i][j]=max(f[i][j],f[i-1][j]);
        &#125;
        if(i-W-1&lt;1) continue;
        l=1,r=0;
        for(int j=0;j&lt;=P;j++)&#123;
            while(l&lt;=r &amp;&amp; que[l]&lt;j-as[i]) l++;
            while(l&lt;=r &amp;&amp; f[i-W-1][que[r]]+que[r]*ap[i]&lt;=f[i-W-1][j]+j*ap[i]) r--;
            que[++r]=j;
            if(l&lt;=r)
                f[i][j]=max(f[i][j],f[i-W-1][que[l]]+(que[l]-j)*ap[i]);
        &#125;
        l=1,r=0;
        for(int j=P;j&gt;=0;j--)&#123;
            while(l&lt;=r &amp;&amp; que[l]&gt;j+bs[i]) l++;
            while(l&lt;=r &amp;&amp; f[i-W-1][que[r]]+que[r]*bp[i]&lt;=f[i-W-1][j]+j*bp[i]) r--;
            que[++r]=j;
            if(l&lt;=r)
                f[i][j]=max(f[i][j],f[i-W-1][que[l]]+(que[l]-j)*bp[i]);
            
        &#125;
    &#125;
    for(int i=0;i&lt;=P;i++)&#123;
        ans=max(ans,f[T][i]);
    &#125;
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<pre><code class="cpp">//瑰丽华尔兹
#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 210;
int n,m,x,y,k;
int mp[N][N],f[N][N];
struct node&#123;
    int val,pos;
&#125;que[N];
int l,r,ans;
int dx[5]=&#123;0,-1,1,0,0&#125;,dy[5]=&#123;0,0,0,-1,1&#125;;
void solve(int x,int y,int len,int d)&#123;
    int l=1,r=0;
    for(int i=1;x&gt;=1 &amp;&amp; x&lt;=n &amp;&amp; y&gt;=1 &amp;&amp; y&lt;=m;i++,x+=dx[d],y+=dy[d])&#123;
        if(mp[x][y]) l=1,r=0;
        else&#123;
            while(l&lt;=r &amp;&amp; que[r].val+i-que[r].pos&lt;f[x][y]) r--;
            que[++r]=&#123;f[x][y],i&#125;;
            while(que[r].pos-que[l].pos&gt;len) l++;
            f[x][y]=que[l].val+i-que[l].pos;
            ans=max(ans,f[x][y]);
        &#125;
    &#125;
&#125;
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y&gt;&gt;k;
    memset(f,128,sizeof(f));
    f[x][y]=0;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=m;j++)&#123;
            char ch;cin&gt;&gt;ch;
            if(ch==&#39;x&#39;)&#123;
                mp[i][j]=1;
            &#125;
        &#125;
    &#125;
    for(int i=1,l,r,d;i&lt;=k;i++)&#123;
        cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;
        int len=r-l+1;
        if(d==1) for(int j=1;j&lt;=m;j++) solve(n,j,len,d);
        if(d==2) for(int j=1;j&lt;=m;j++) solve(1,j,len,d);
        if(d==3) for(int j=1;j&lt;=n;j++) solve(j,m,len,d);
        if(d==4) for(int j=1;j&lt;=n;j++) solve(j,1,len,d);
    &#125;
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<p>转移方程怎么推的参考题解吧。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的用处太大了，拥有优秀的复杂度的同时，还支持拓展。而且拓展的性质也很好。</p>
<h3 id="免费道路"><a href="#免费道路" class="headerlink" title="免费道路"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3623">免费道路</a></h3><p>这里的并查集只维护连通性。</p>
<p>将边降序排序能选出一定要的 1 边，升序能选出一定要的 0 边。</p>
<p>剩下的随便填即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 2e4+10;
int n,m,k,fa[N];
int find(int x)&#123;return x==fa[x] ? x : fa[x]=find(fa[x]);&#125;
struct Edge&#123;
    int u,v,w;
&#125;e[N&lt;&lt;3],ans[N&lt;&lt;3];
int tot,cnt,sum;
bool cmp1(Edge a,Edge b)&#123;
    return a.w&gt;b.w;
&#125;
bool cmp2(Edge a,Edge b)&#123;
    return a.w&lt;b.w;
&#125;
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        fa[i]=i;
    &#125;
    sort(e+1,e+1+m,cmp1);
    for(int i=1;i&lt;=m;i++)&#123;
        int u=e[i].u,v=e[i].v;
        int fu=find(u),fv=find(v);
        if(fu==fv) continue;
        fa[fv]=fu;sum++;
        if(e[i].w==0)&#123;
            e[i].w=-1;
            tot++;
        &#125;
    &#125;
    if(tot&gt;k || sum!=n-1)&#123;
        cout &lt;&lt; &quot;no solution&quot;;return 0;
    &#125;
    sort(e+1,e+1+m,cmp2);
    for(int i=1;i&lt;=n;i++) fa[i]=i;
    sum=0,tot=0;
    for(int i=1;i&lt;=m;i++)&#123;
        int u=e[i].u,v=e[i].v;
        int fu=find(u),fv=find(v);
        if(fu==fv) continue;
        if(e[i].w==1 || tot&lt;k)&#123;
            fa[fv]=fu,ans[++cnt]=e[i];
            sum++;
            if(e[i].w&lt;1)&#123;
                tot++,e[i].w=0;
            &#125;
        &#125;
    &#125;
    if(tot&lt;k || sum!=n-1)&#123;
        cout &lt;&lt; &quot;no solution&quot;;return 0;
    &#125;
    for(int i=1;i&lt;=cnt;i++)&#123;
        if(ans[i].w==-1) ans[i].w=0;
        cout&lt;&lt;ans[i].u&lt;&lt;&#39; &#39;&lt;&lt;ans[i].v&lt;&lt;&#39; &#39;&lt;&lt;ans[i].w&lt;&lt;&#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5227">连通图</a></h3><p>线段树分治还是太强大了。</p>
<p>对时间轴开线段树，树上维护每段时间出现了哪些边。</p>
<p>这个可以在输入的时候做。</p>
<p>然后进线段树去操作，并查集维护连通性。</p>
<p>从儿子出来的时候要撤销，所以需要可撤销并查集。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
using namespace std;
const int N=2e5+10;
int n,m,k;
struct Edge&#123;
    int u,v;
&#125;e[N&lt;&lt;1];
vector&lt;int&gt; vec[N];
vector&lt;int&gt; tr[N&lt;&lt;2];
void insert(int u,int l,int r,int x,int y,int k)&#123;
    if(l&gt;=x &amp;&amp; r&lt;=y)&#123;
        tr[u].push_back(k);
        return ;
    &#125;
    int mid=(l+r)&gt;&gt;1;
    if(x&lt;=mid) insert(ls,l,mid,x,y,k);
    if(mid&lt;y) insert(rs,mid+1,r,x,y,k);
&#125;
int fa[N],siz[N];
int sta[N],top;
int find(int x)&#123;return fa[x]==x ? x : find(fa[x]);&#125;
inline void merge(int x,int y)&#123;
    if(siz[x]&gt;siz[y]) swap(x,y);
    fa[x]=y;
    siz[y]+=siz[x];
    sta[++top]=x;
&#125;
inline void goback(int lst)&#123;
    while(top&gt;lst)&#123;
        int y=sta[top--];
        siz[fa[y]]-=siz[y];
        fa[y]=y;
    &#125;
&#125;
void solve(int u,int l,int r,bool f)&#123;
    int lst=top;
    for(auto tim:tr[u])&#123;
        int u=e[tim].u,v=e[tim].v;
        int fu=find(u),fv=find(v);
        if(fu==fv) continue;
        merge(fu,fv);
        if(siz[find(u)]==n)&#123;
            f=true;
        &#125;
    &#125;
    if(l==r)&#123;
        cout &lt;&lt; (f==1 ? &quot;Connected&quot; : &quot;Disconnected&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;else&#123;
        int mid=(l+r)&gt;&gt;1;
        solve(ls,l,mid,f);
        solve(rs,mid+1,r,f);
    &#125;
    goback(lst);
&#125;
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v;
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        vec[i].push_back(0);
    &#125;
    cin&gt;&gt;k;
    for(int i=1;i&lt;=k;i++)&#123;
        int k;cin&gt;&gt;k;
        for(int j=1;j&lt;=k;j++)&#123;
            int c;cin&gt;&gt;c;
            vec[c].push_back(i);
        &#125;
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        vec[i].push_back(k+1);
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        for(int j=1;j&lt;(int)vec[i].size();j++)&#123;
            if(vec[i][j-1]+1&lt;=vec[i][j]-1)&#123;
                insert(1,1,k,vec[i][j-1]+1,vec[i][j]-1,i);
            &#125;
        &#125;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        fa[i]=i,siz[i]=1;
    &#125;
    solve(1,1,k,0);
    return 0;
&#125;
</code></pre>
<h3 id="倍增优化建图-逛森林"><a href="#倍增优化建图-逛森林" class="headerlink" title="倍增优化建图 逛森林"></a>倍增优化建图 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5344">逛森林</a></h3><p>考虑形如线段树优化建图，但不开那么大的空间。而且常数还比线段树小。</p>
<p>用倍增来表示某一条链，具体实现非常……</p>
<p>对于本题而言，可以将 2 的边连好后，判断有哪些 1 边可以被连接（并查集），再统一连 1 的边。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 2e5+10;
const int M = 1e6+10;
int n,m,s;
struct node&#123;
    int v,w;
&#125;;
struct Que&#123;
    int u,v,x,y,w;
&#125;que[M];
int cnt,lim,tot;
vector&lt;node&gt; G[N*20];
vector&lt;int&gt; tr[N];
int fa[50010],f[N][18],dep[50010];
int in[N][18],out[N][18];
int find(int x)&#123;return fa[x]==x ? x : fa[x]=find(fa[x]);&#125;
void dfs(int u,int father)&#123;
    dep[u]=dep[father]+1;f[u][0]=father;
    in[u][0]=++tot;G[tot].push_back(&#123;u,0&#125;);G[tot].push_back(&#123;father,0&#125;);
    out[u][0]=++tot;G[u].push_back(&#123;tot,0&#125;);G[father].push_back(&#123;tot,0&#125;);
    for(int j=1;j&lt;=lim;j++)&#123;
        f[u][j]=f[f[u][j-1]][j-1];
        in[u][j]=++tot;G[tot].push_back(&#123;in[u][j-1],0&#125;);G[tot].push_back(&#123;in[f[u][j-1]][j-1],0&#125;);
        out[u][j]=++tot;G[out[u][j-1]].push_back(&#123;tot,0&#125;);G[out[f[u][j-1]][j-1]].push_back(&#123;tot,0&#125;);
    &#125;
    for(int v:tr[u])&#123;
        if(v==father) continue;
        dfs(v,u);
    &#125;
&#125;
void lca1(int x,int y,int k)&#123;
    if(dep[x]&lt;dep[y]) swap(x,y);
    G[y].push_back(&#123;k,0&#125;);
    for(int i=lim;i&gt;=0;i--)&#123;
        if(dep[f[x][i]]&gt;=dep[y])&#123;
            G[out[x][i]].push_back(&#123;k,0&#125;);
            x=f[x][i];
        &#125;
    &#125;
    if(x==y) return ;
    for(int i=lim;i&gt;=0;i--)&#123;
        if(f[x][i]!=f[y][i])&#123;
            G[out[x][i]].push_back(&#123;k,0&#125;);x=f[x][i];
            G[out[y][i]].push_back(&#123;k,0&#125;);y=f[y][i];
        &#125;
    &#125;
    G[out[x][0]].push_back(&#123;k,0&#125;);
&#125;
void lca2(int x,int y,int k)&#123;
    if(dep[x]&lt;dep[y]) swap(x,y);
    G[k].push_back(&#123;y,0&#125;);
    for(int i=lim;i&gt;=0;i--)&#123;
        if(dep[f[x][i]]&gt;=dep[y])&#123;
            G[k].push_back(&#123;in[x][i],0&#125;);
            x=f[x][i];
        &#125;
    &#125;
    if(x==y) return ;
    for(int i=lim;i&gt;=0;i--)&#123;
        if(f[x][i]!=f[y][i])&#123;
            G[k].push_back(&#123;in[x][i],0&#125;);x=f[x][i];
            G[k].push_back(&#123;in[y][i],0&#125;);y=f[y][i];
        &#125;
    &#125;
    G[k].push_back(&#123;in[x][0],0&#125;);
&#125;
struct DIJ&#123;
    int id,val;
    bool operator &lt; (const DIJ &amp;a)const&#123;
        return val&gt;a.val;
    &#125;
&#125;;
int dis[N*20];
bool vis[N*20];
void dijsktra()&#123;
    memset(dis,0x3f,sizeof(dis));
    priority_queue&lt;DIJ&gt; q;
    q.push(&#123;s,0&#125;);
    dis[s]=0;
    while(!q.empty())&#123;
        auto u=q.top();q.pop();
        if(vis[u.id]) continue;
        vis[u.id]=1;
        for(auto to:G[u.id])&#123;
            int v=to.v,w=to.w;
            if(dis[v]&gt;dis[u.id]+w)&#123;
                dis[v]=dis[u.id]+w;
                q.push(&#123;v,dis[v]&#125;);
            &#125;
        &#125;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        cout &lt;&lt; (dis[i]==0x3f3f3f3f ? -1 : dis[i]) &lt;&lt; &#39; &#39;;
    &#125;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    while((1&lt;&lt;lim)&lt;=n) ++lim;
    lim--;tot=n;
    for(int i=1;i&lt;=n;i++) fa[i]=i;
    for(int i=1,op,u,v,w;i&lt;=m;i++)&#123;
        cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;
        if(op==1)&#123;
            int x,y;
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
            if(find(x)!=find(y) || find(u)!=find(v)) continue;
            que[++cnt]=&#123;u,v,x,y,w&#125;;
        &#125;else&#123;
            cin&gt;&gt;w;
            int fu=find(u),fv=find(v);
            if(fu==fv) continue;
            tr[u].push_back(v);tr[v].push_back(u);
            G[u].push_back(&#123;v,w&#125;);
            G[v].push_back(&#123;u,w&#125;);
            fa[fu]=fv;
        &#125;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(!dep[i]) dfs(i,0);
    &#125;
    for(int i=1;i&lt;=cnt;i++)&#123;
        lca1(que[i].u,que[i].v,++tot);
        lca2(que[i].x,que[i].y,++tot);
        G[tot-1].push_back(&#123;tot,que[i].w&#125;);
    &#125;
    dijsktra();
    
    return 0;
&#125;
</code></pre>
<h2 id="2025-7-3"><a href="#2025-7-3" class="headerlink" title="2025.7.3"></a>2025.7.3</h2><p>Trie树+笛卡尔树+DS</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie树原来还有这么多好玩的性质啊。</p>
<h3 id="First-G"><a href="#First-G" class="headerlink" title="First! G"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3065">First! G</a></h3><p>建Trie树，因为字符总长 3e6，直接暴力check每一个字符串即可。</p>
<p>然后就是check，我们想让某个最大，肯定要钦定一系列大小关系。</p>
<p>然后根据大小关系连成图，topo判环即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N=3e4+10;
int n,ans[N],cnt;
string s[N];
struct Trie&#123;
    struct node&#123;
        int son[26];
        int cnt;
    &#125;tr[10*N];
    int tot,in[26],mp[26][26];
    void insert(const string &amp;s)&#123;
        int u=0;
        for(char ch:s)&#123;
            int &amp;son=tr[u].son[ch-&#39;a&#39;];
            if(!son) son=++tot;
            u=son;
        &#125;
        tr[u].cnt+=1;
    &#125;
    void topo()&#123;
        queue&lt;int&gt; que;
        for(int i=0;i&lt;26;i++)&#123;
            if(in[i]==0) que.push(i);
        &#125;
        while(!que.empty())&#123;
            int u=que.front();que.pop();
            for(int i=0;i&lt;26;i++)&#123;
                if(mp[u][i])&#123;
                    in[i]--;
                    if(!in[i]) que.push(i);
                &#125;
            &#125;
        &#125;
    &#125;
    bool check(const string &amp;s)&#123;
        memset(in,0,sizeof(in));
        memset(mp,0,sizeof(mp));
        int u=0;
        for(char ch:s)&#123;
            if(tr[u].cnt) return 0;
            for(int i=0;i&lt;26;i++)&#123;
                if(tr[u].son[i] &amp;&amp; i!=ch-&#39;a&#39; &amp;&amp; !mp[ch-&#39;a&#39;][i])&#123;
                    mp[ch-&#39;a&#39;][i]=1;
                    in[i]++;
                &#125;
            &#125;
            u=tr[u].son[ch-&#39;a&#39;];
        &#125;
        topo();
        for(int i=0;i&lt;26;i++)&#123;
            if(in[i]) return 0;
        &#125;
        return 1;
    &#125;
    
&#125;T;
int main()&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;s[i];
        T.insert(s[i]);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(T.check(s[i]))&#123;
            ans[++cnt]=i;
        &#125;
    &#125;
    cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
    for(int i=1;i&lt;=cnt;i++)&#123;
        cout &lt;&lt; s[ans[i]] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="电子字典"><a href="#电子字典" class="headerlink" title="电子字典"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4407">电子字典</a></h3><p>建Trie树，然后接下来考虑在 Trie 上走。</p>
<p>字符串长度小于 20，暴力 DFS 即可。</p>
<p>下面长度指匹配的字符串在第几位。</p>
<ul>
<li><p>增：任意到达这个节点的儿子，长度不增。</p>
</li>
<li><p>删：保留当前节点，长度增加。</p>
</li>
<li><p>改：任意匹配这个节点的儿子，长度增加。</p>
</li>
</ul>
<p>然后就没了，DFS即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N=1e4+10;
struct node&#123;
    int son[26];
    int cnt;
&#125;tr[20*N];
bool vis[20*N];
int n,m,tot,ans,vx[N],len;
string s;
void insert(const string &amp;s)&#123;
    int u=0;
    for(char ch:s)&#123;
        int &amp;son=tr[u].son[ch-&#39;a&#39;];
        if(!son) son=++tot;
        u=son;
    &#125;
    tr[u].cnt++;
&#125;
bool flag=0;
void dfs(int u,int l,bool f)&#123;
    if(tr[u].cnt &amp;&amp; l==len &amp;&amp; !f)&#123;
        flag=1;return;
    &#125;
    if(tr[u].cnt &amp;&amp; l==len &amp;&amp; f)&#123;
        if(!vis[u])&#123;
            vx[++ans]=u;
            vis[u]=1;
        &#125;
        return;
    &#125;
    int ch=s[l]-&#39;a&#39;;
    if(!f)&#123;
        if(l&lt;len) dfs(u,l+1,1);
        for(int i=0;i&lt;26;i++)&#123;
            if(tr[u].son[i])&#123;
                dfs(tr[u].son[i],l,1);
                if(i!=ch) dfs(tr[u].son[i],l+1,1);
            &#125;
        &#125;
    &#125;
    if(l&gt;=len) return;
    if(tr[u].son[ch]) dfs(tr[u].son[ch],l+1,f);
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;s;
        insert(s);
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;s;len=s.length();
        dfs(0,0,0);
        if(flag) cout &lt;&lt; &quot;-1\n&quot;;
        else cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
        while(ans) vis[vx[ans--]]=0;
        flag=0;
    &#125;
    
    return 0;
&#125;
</code></pre>
<h3 id="Type-Printer"><a href="#Type-Printer" class="headerlink" title="Type Printer"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4683">Type Printer</a></h3><p>先无脑建出Trie树，然后考虑怎么走最优。</p>
<p>发现是著名贪心结论，先走散链，再走最长链。</p>
<p>读入时比较长度保留最长链，然后给最长链上标记。</p>
<p>然后DFS一遍即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 5e5+10; 
int n,tot;
string s,mx;
struct node&#123;
    int son[26];
    int cnt;
    bool vis;
&#125;tr[N];
void insert(const string &amp;s,bool op)&#123;
    if(op==1)&#123;
        int u=0;
        for(char ch:s)&#123;
            u=tr[u].son[ch-&#39;a&#39;];
            tr[u].vis=1;
        &#125;
        return ;
    &#125;
    int u=0;
    for(char ch : s)&#123;
        int &amp;son=tr[u].son[ch-&#39;a&#39;];
        if(!son) son=++tot;
        u=son;
    &#125;
    tr[u].cnt++;
&#125;
char ans[N&lt;&lt;1];
int cnt;
bool f=false;
void dfs(int u)&#123;
    int v=-1;
    if(tr[u].cnt)&#123;
        for(int i=1;i&lt;=tr[u].cnt;i++) ans[++cnt]=&#39;P&#39;;
    &#125;
    for(int i=0;i&lt;26;i++)&#123;
        if(tr[tr[u].son[i]].vis) v=i;
        else if(tr[u].son[i])&#123;
            ans[++cnt]=i+&#39;a&#39;;
            dfs(tr[u].son[i]);
        &#125;
    &#125;
    if(v!=-1)&#123;
        ans[++cnt]=v+&#39;a&#39;;
        dfs(tr[u].son[v]);
    &#125;
    if(v==-1 &amp;&amp; tr[u].vis)&#123;
        f=true;
    &#125;
    if(!f)&#123;
        ans[++cnt]=&#39;-&#39;;
    &#125;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;s;
        insert(s,0);
        if(s.length()&gt;mx.length())&#123;
            mx=s;
        &#125;
    &#125;
    insert(mx,1);
    dfs(0);
    cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
    for(int i=1;i&lt;=cnt;i++)&#123;
        cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="最大异或和"><a href="#最大异或和" class="headerlink" title="最大异或和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4735">最大异或和</a></h3><p>可持久化 01 Trie，写法形如主席树即可。</p>
<p>询问的时候贪心一下，走相反的。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N=6e5+10;
int n,m,a[N];
int rt[N],tr[N&lt;&lt;5];
int son[N&lt;&lt;5][2];
int tot=1;
void insert(int now,int pre,int t,int x)&#123;
    if(t&lt;0) return ;
    int i=(x&gt;&gt;t)&amp;1;
    son[now][!i]=son[pre][!i];
    son[now][i]=tot++;
    tr[son[now][i]]=tr[son[pre][i]]+1;
    insert(son[now][i],son[pre][i],t-1,x);
&#125;
int query(int now,int pre,int t,int x)&#123;
    if(t&lt;0) return 0;
    int i=(x&gt;&gt;t)&amp;1;
    if(tr[son[pre][!i]]&gt;tr[son[now][!i]])&#123;
        return (1&lt;&lt;t)+query(son[now][!i],son[pre][!i],t-1,x);
    &#125;else&#123;
        return query(son[now][i],son[pre][i],t-1,x);
    &#125;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    rt[0]=tot++;
    insert(rt[0],0,25,0);
    for(int i=1;i&lt;=n;i++)&#123;
        int b;cin&gt;&gt;b;
        a[i]=a[i-1]^b;
        rt[i]=tot++;
        insert(rt[i],rt[i-1],25,a[i]);
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        char op;
        cin&gt;&gt;op;
        if(op==&#39;A&#39;)&#123;
            int x;cin&gt;&gt;x;
            n++;
            a[n]=a[n-1]^x;
            rt[n]=tot++;
            insert(rt[n],rt[n-1],25,a[n]);
        &#125;else&#123;
            int l,r,x;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;
            l--,r--;
            if(l==0) cout &lt;&lt; query(0,rt[r],25,x^a[n]) &lt;&lt; &#39;\n&#39;;
            else cout &lt;&lt; query(rt[l-1],rt[r],25,x^a[n]) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="异或粽子"><a href="#异或粽子" class="headerlink" title="异或粽子"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5283">异或粽子</a></h3><p>拼好题，把最大异或和的代码贺下来，询问改成回答位置。拼上超级钢琴即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define ll long long
using namespace std;
const int N = 5e5+10;
int n,m,rt[N],tot;
ll a[N],ans;
struct Trie&#123;
    int son[2],sum,id;
&#125;tr[40*N];
void insert(int &amp;now,int pre,int t,int id,ll x)&#123;
    now=++tot;tr[now]=tr[pre];tr[now].sum++;
    if(t==-1)&#123;tr[now].id=id;return;&#125;
    int i=(x&gt;&gt;t)&amp;1;
    insert(tr[now].son[i],tr[pre].son[i],t-1,id,x);
&#125;
int query(int l,int r,int t,ll x)&#123;
    if(t==-1) return tr[r].id;
    int i=(x&gt;&gt;t)&amp;1;
    if(tr[tr[r].son[i^1]].sum&gt;tr[tr[l].son[i^1]].sum) return query(tr[l].son[i^1],tr[r].son[i^1],t-1,x);
    else return query(tr[l].son[i],tr[r].son[i],t-1,x);
&#125;
struct Num&#123;
    int l,r,x,id;
    ll val;
    Num(int nl=0,int nr=0,int nx=0)&#123;
        l=nl;r=nr;x=nx;
        id=query(rt[l-1],rt[r],32,a[x]);
        val=a[x]^a[id-1];
    &#125;
    bool operator &lt; (const Num &amp;a)const&#123;
        return val&lt;a.val;
    &#125;
&#125;;
priority_queue&lt;Num&gt; que;
signed main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        int b;cin&gt;&gt;b;
        a[i]=a[i-1]^b;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        rt[i]=rt[i-1];
        insert(rt[i],rt[i],32,i,a[i-1]);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        que.push(Num(1,i,i));
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        Num u=que.top();que.pop();
        ans+=u.val;
        if(u.l&lt;u.id) que.push(Num(u.l,u.id-1,u.x));
        if(u.id&lt;u.r) que.push(Num(u.id+1,u.r,u.x));
    &#125;
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<h3 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h3><p>其实没听懂，只能全文背诵了，先【TBD】了。</p>
<h3 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h3><p>有……大家要一起吃啊！</p>
<h3 id="超级钢琴"><a href="#超级钢琴" class="headerlink" title="超级钢琴"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2048">超级钢琴</a></h3><p>先来个比较有好的。</p>
<p>对前缀和做 ST 表解决区间不定长最大子段和。</p>
<p>然后扔入堆里，每次取的时候，把原区间劈成两半再放入堆里。</p>
<p>取 k 个就是答案。代码有点古老了，凑合看吧。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,k,L,R;
int a[501000];
int st[501000][50];
int d[501000][50];
int lg2[501000];
int arr[501000];
struct node&#123;
    int sum,sd,id;
    //sum=当前的字段和 
    //sd=开始的点
    //id=l-r区间内选的最小值的点 
    int ll,rr;
    //ll=以st为末尾长度为ll 
    //rr=以st为末尾长度为rr 
    friend bool operator &lt; (struct node a,struct node b) &#123;
        return a.sum &lt; b.sum;
    &#125;
&#125;;
priority_queue&lt;node,vector&lt;node&gt;,less&lt;node&gt; &gt; q;
int ask2(int l,int r)&#123;
    int j=lg2[r-l+1];
    if(st[l][j]&gt;st[r-(1&lt;&lt;j)+1][j])&#123;
        return d[l][j];
    &#125;else&#123;
        return d[r-(1&lt;&lt;j)+1][j];
    &#125;
&#125;
void init()&#123;
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;L&gt;&gt;R;
    for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];arr[i]=arr[i-1]+a[i];d[i][0]=i;if(i&gt;=2) lg2[i]=lg2[i/2]+1;&#125;
    for(int i=1;i&lt;=n;i++) st[i][0]=arr[i];
    for(int j=1;(1&lt;&lt;j)&lt;=n;j++)&#123;
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;
            if(st[i][j-1]&lt;st[i+(1&lt;&lt;(j-1))][j-1])&#123;
                st[i][j]=st[i+(1&lt;&lt;(j-1))][j-1];
                d[i][j]=d[i+(1&lt;&lt;(j-1))][j-1];
            &#125;else&#123;
                st[i][j]=st[i][j-1];
                d[i][j]=d[i][j-1];
            &#125;
        &#125;
    &#125;
    return;
&#125;
void add(int w,int i,int l,int r)&#123;
    node d;
    d.sum=arr[w]-arr[i-1];
    d.rr=r;d.ll=l;
    d.id=i;d.sd=w;
    q.push(d);
&#125;
int main()&#123;
    ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);
    init();
    for(int i=1;i+L-1&lt;=n;i++)&#123;
        add(ask2(i+L-1,min(i+R-1,n)),i,i+L-1,min(i+R-1,n));
    &#125;
    long long ans=0;
    for(int i=1;i&lt;=k;i++)&#123;
        node k=q.top();
        q.pop();
        ans+=k.sum;
        int st=k.sd,j=k.id;
        int l=k.ll,r=k.rr;
        if(st&gt;l)&#123;
            add(ask2(l,st-1),j,l,st-1);
        &#125;
        if(st&lt;r)&#123;
            add(ask2(st+1,r),j,st+1,r);
        &#125;
    &#125;
    cout&lt;&lt;ans;
    return 0;
&#125; 
/*做前缀和后求最大不定长字段和（利用st表）
  利用优先队列存可能的最优解
  每次取队头的值进行累加
*/ 
</code></pre>
<h3 id="Sasha-and-Array"><a href="#Sasha-and-Array" class="headerlink" title="Sasha and Array"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF718C">Sasha and Array</a></h3><p>Tmbcan：听我说，我那个结论一定是对的，就是要卡常而已。</p>
<p>众所周知，斐波那契可以拿矩阵维护，直接扔线段树上。</p>
<p>节点存矩阵，加法操作变成给维护的矩阵乘上 $x$ 次幂。</p>
<p>代码太屎了。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 1e5+10;
const int p = 1e9+7;
int n,m,a[N];
struct Matrix&#123;
    int a[5][5];
    void clear()&#123;
        for(int i=0;i&lt;4;i++)
            for(int j=0;j&lt;4;j++)
                a[i][j]=0;
    &#125;
    void init()&#123;
        for(int i=0;i&lt;4;i++) a[i][i]=1;
    &#125;
    bool empty()&#123;
        if(a[1][1]!=1) return 0;
        if(a[1][2]!=0) return 0;
        if(a[2][1]!=0) return 0;
        if(a[2][2]!=1) return 0;
        return 1;
    &#125;
    Matrix operator + (const Matrix &amp;b)const&#123;
        Matrix res;res.clear();
        for(int i=1;i&lt;=2;i++)&#123;
            for(int j=1;j&lt;=2;j++)&#123;
                res.a[i][j]=(a[i][j]+b.a[i][j])%p;
            &#125;
        &#125;
        return res;
    &#125;
    Matrix operator * (const Matrix &amp;b)const&#123;
        Matrix res;res.init();res.clear();
        for(int k=1;k&lt;=2;k++)&#123;
            for(int i=1;i&lt;=2;i++)&#123;
                for(int j=1;j&lt;=2;j++)&#123;
                    res.a[i][j]=(res.a[i][j]+1ll*a[i][k]*b.a[k][j]%p)%p;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;	
&#125;;
Matrix qpow(Matrix a,int b)&#123;
    Matrix res;res.clear();res.init();
    while(b)&#123;
        if(b&amp;1) res=res*a;
        a=a*a;
        b&gt;&gt;=1;
    &#125;
    return res;
&#125;
Matrix g,F;
struct SegTree&#123;
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define mid ((l+r)&gt;&gt;1)
    struct Tree&#123;
        Matrix sum,tag;
    &#125;tr[N&lt;&lt;2];
    void pushup(int u)&#123;
        tr[u].sum=tr[ls].sum+tr[rs].sum;
    &#125;
    void upd(int u,Matrix k)&#123;
        tr[u].sum=tr[u].sum*k;
        tr[u].tag=tr[u].tag*k;
    &#125;
    void pushdown(int u)&#123;
        if(tr[u].tag.empty()) return ;
        upd(ls,tr[u].tag);
        upd(rs,tr[u].tag);
        tr[u].tag.clear();
        tr[u].tag.init();
    &#125;
    void build(int u,int l,int r)&#123;
        tr[u].sum.clear();tr[u].tag.clear();
        tr[u].tag.init();
        if(l==r)&#123;
            tr[u].sum=F*qpow(g,a[l]-1);
            return;
        &#125;
        build(ls,l,mid);build(rs,mid+1,r);pushup(u);
    &#125;
    void modify(int u,int l,int r,int x,int y,Matrix k)&#123;
        if(l&gt;=x &amp;&amp; r&lt;=y)&#123;upd(u,k);return;&#125;
        pushdown(u);
        if(x&lt;=mid) modify(ls,l,mid,x,y,k);
        if(mid&lt;y) modify(rs,mid+1,r,x,y,k);
        pushup(u);
    &#125;
    Matrix query_sum(int u,int l,int r,int x,int y)&#123;
        if(l&gt;=x &amp;&amp; r&lt;=y) return tr[u].sum;
        pushdown(u);
        Matrix res;res.clear();
        if(x&lt;=mid) res=res+query_sum(ls,l,mid,x,y);
        if(mid&lt;y) res=res+query_sum(rs,mid+1,r,x,y);
        return res;
    &#125;
&#125;Tr;

int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    g.clear();F.clear();
    g.a[1][1]=g.a[1][2]=g.a[2][1]=1;g.a[2][2]=0;
    F.a[1][1]=F.a[1][2]=1;F.a[2][1]=F.a[2][2]=0;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;a[i];
    &#125;
    Tr.build(1,1,n);
    for(int i=1,op,l,r;i&lt;=m;i++)&#123;
        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;
        if(op==1)&#123;
            int x;cin&gt;&gt;x;
            Tr.modify(1,1,n,l,r,qpow(g,x));
        &#125;else&#123;
            cout &lt;&lt; Tr.query_sum(1,1,n,l,r).a[1][2]%p &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="2025-7-4"><a href="#2025-7-4" class="headerlink" title="2025.7.4"></a>2025.7.4</h2><p>上午模拟赛，质量是这几次最好的一场了。（如果没有原题的话）</p>
<p>T2 我记得要两次背包，边界被 dbg 卡飞了+写丑了 成功死完了。</p>
<p>导致 lcx 拿到 rk1，我谢罪。</p>
<p>T4 是原，直接全文背诵了，看两版代码的编辑距离不超 50 字符。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>小奥数学题，没推出来觉得 T2 能冲正解。</p>
<p>边界先扔一边，注意到每次创造后只需要补 $m-k$ 个就可以再次创造。</p>
<p>而每次创造剩的 $m$ 个没有用，所以直接攻击。</p>
<p>总计要创造 $\frac{h}{m}$ 次，最后还会剩一点点，可以补足创造，也可以直接攻击。</p>
<p>然后几个比较自然的边界不讨论了。</p>
<p>有个方便的方法，再计算前先让 $h&#x3D;h-m-k$ ，这样后续就不用考虑很多边角。</p>
<pre><code class="cpp">#include&lt;iostream&gt;

using namespace std;
int T,k,m,h;

int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;T;
    while(T--)&#123;
        cin&gt;&gt;m&gt;&gt;k&gt;&gt;h;
        if(h&lt;=m)&#123;
            cout &lt;&lt; h &lt;&lt; &#39;\n&#39;;continue;
        &#125;
        if(m&lt;=k || h&lt;m+k)&#123;
            cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;continue;
        &#125;
        h-=m+k;
        cout &lt;&lt; h/m*(m-k)+m+min(h%m,m-k) &lt;&lt; &#39;\n&#39;;
    &#125;
    
    return 0;
&#125;
</code></pre>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>dbg 学长认真随的数据。</p>
<p>开题前一个小时没有读到 <strong>无限</strong> 太痛了。</p>
<p>背包体积反正是 $m$，我们贪心的想，同价值下肯定希望“金辉石”越多越好，所以先做一个完全背包。</p>
<p>定义 $f_{j}$ 表示质量为 $j$ 的物品含有最大的“金辉石”质量。</p>
<p>$$f_j&#x3D;\max(f_{j},f_{j-w_i}+v_i)$$</p>
<p>直接把物品全替换掉。</p>
<p>然后再做一次完全背包就是答案。</p>
<p>两次背包的trick要记住了。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
const int N=3e3+10;
int T,val[15],n,m;
struct Num&#123;
    int w,v;
&#125;a[N];
int bel(int a,int b)&#123;
    return val[((b*10-1)/a)+1]*a;
&#125;
int c[N],f[N];
signed main()&#123;
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin&gt;&gt;T;
    while(T--)&#123;
        memset(f,0,sizeof(f));memset(c,-0x3f,sizeof(c));
        for(int i=1;i&lt;=10;i++) cin&gt;&gt;val[i];
        cin&gt;&gt;n&gt;&gt;m;
        for(int i=1;i&lt;=n;i++)&#123;
            cin&gt;&gt;a[i].w&gt;&gt;a[i].v;
        &#125;
        f[0]=c[0]=0;
        for(int i=1;i&lt;=n;i++)&#123;
            for(int j=a[i].w;j&lt;=m;j++)&#123;
                c[j]=max(c[j],c[j-a[i].w]+a[i].v);
            &#125;
        &#125;
        for(int i=1;i&lt;=m;i++)&#123;
            for(int j=i;j&lt;=m;j++)&#123;
                if(c[i]&gt;0) f[j]=max(f[j],f[j-i]+bel(i,c[i]));
            &#125;
        &#125;
        cout &lt;&lt; f[m] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;	

</code></pre>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>从未见过的 trick，太强了。</p>
<p>我们不在乎字符串的每一位是什么，只在乎它的格式或者形态或者相对位置。</p>
<p>维护相同值上一次出现的距离差，就直接维护了这个字符串的形态&#x2F;格式。</p>
<p>然后做 KMP 或者 hash 即可。 </p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define N 1000010
using namespace std;
int T,C,cnt;
int n,m,a[N],b[N],s1[N],s2[N],lst[N],ans[N],nxt[N];
int is(int x,int l)&#123;return x&lt;l ? x : 0;&#125;
void init()&#123;
    cnt=0;
    memset(s1,0,sizeof(s1));
    memset(s2,0,sizeof(s2));
    memset(ans,0,sizeof(ans));
    memset(nxt,0,sizeof(nxt));
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;T&gt;&gt;C;
    while(T--)&#123;
        cin&gt;&gt;n&gt;&gt;m;
        init();
        memset(lst,0,sizeof(lst));
        for(int i=1;i&lt;=n;i++)&#123;
            cin&gt;&gt;a[i];
        &#125;
        for(int i=1;i&lt;=n;i++)&#123;
            if(!lst[a[i]]) s1[i]=i;
            else s1[i]=i-lst[a[i]];
            lst[a[i]]=i;
        &#125;
        memset(lst,0,sizeof(lst));
        for(int i=1;i&lt;=m;i++)&#123;
            cin&gt;&gt;b[i];
        &#125;
        for(int i=1;i&lt;=m;i++)&#123;
            if(!lst[b[i]]) s2[i]=i;
            else s2[i]=i-lst[b[i]];
            lst[b[i]]=i;
        &#125;
        for(int i=2,j=0;i&lt;=m;i++)&#123;
            while(j &amp;&amp; is(s2[i],j+1)!=is(s2[j+1],j+1)) j=nxt[j];
            if(is(s2[i],j+1)==is(s2[j+1],j+1)) j++;
            nxt[i]=j;
        &#125;
        for(int i=1,j=0;i&lt;=n;i++)&#123;
            while(j &amp;&amp; is(s1[i],j+1)!=is(s2[j+1],j+1)) j=nxt[j];
            if(is(s1[i],j+1)==is(s2[j+1],j+1)) j++;
            if(j==m)&#123;
                ans[++cnt]=i-j+1;
                j=nxt[j];
            &#125;
        &#125;
        cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
        for(int i=1;i&lt;=cnt;i++)&#123;
            cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
        &#125;cout &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>扔个这个自己讲题的时候也憋不住笑了吗</p>
<p>题解我发 S2OJ 了，这里的是 copy 的。</p>
<p>观察题目可以发现，我们能想出两种暴力做法：</p>
<ol>
<li><p>暴力模拟所有操作，询问时搜索，单次是 $O(1)$ 和 $O(n)$ 的。</p>
</li>
<li><p>离线询问按降序排序，每次回答时重跑时间轴之前的操作，然后拿可撤销并查集维护连通性，单次是 $O(n\log n)$ 和 $O(\log n)$ 的。</p>
</li>
</ol>
<p>发现这两种暴力从截然不同的角度出发，一个枚举边，一个枚举询问。</p>
<p>复杂度分别是 $O(1)$ 修改，$O(n)$ 查询 和 $O(n\log n)$ 修改，$O(\log n)$ 查询。 </p>
<p>所以我们使用分块将这平衡一下。</p>
<p>简单而言，定义一个阈值 $B$，当积压的操作达到 $B$ 的时候处理当前所有操作，同样使用可撤销并查集维护一下。</p>
<p>我们会把操作分成 $\frac{q}{B}$ 块，每块最多 $B$ 个操作。</p>
<p>每个操作有 $O(B)$ 条边将被修改，所以修改的复杂度是 $O(B\log n)$ 的。</p>
<p>有 $O(B)$ 次查询，复杂度是 $O(B\log n)$ 的。</p>
<p>同时需要把无影响的边按边权顺序放入并查集，这个是 $O(m\log n)$ 的。</p>
<p>将 B 带入上面的暴力复杂度，得到最后式子是 $O(qB\log n + \frac{qm\log m}{B})$ ，$B$ 取个 $\sqrt {mlogn}$ 据说跑的飞快，但是我 $B$ 取了个附近的定值，也跑过了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%A1%A5%E6%A2%81.cpp">代码</a> </p>
<p>同学说第一条暴力对下文没有关联，也跟算法没有关联。</p>
<p>其实是有的，分块平衡复杂度的必要条件应该是可以 $O(1)​$ 修改和 $O(n)​$ 查询的同时，能做到 $O(n)​$ 修改和 $O(1)​$ 查询。</p>
<p>注：这里的 $O(1)$ 广泛地指能接受的复杂度，像上文第二个暴力带 log 的原因是要上并查集。</p>
<p>目前没见到条件以外能用分块的题。</p>
<p>两个暴力是有联系的，两个暴力的复杂度互相依赖。</p>
<p>比如第二个暴力的复杂度可以认为是修改 n 次，也就是 n 次 $O(1)$ 。</p>
<p>分块平衡了其中一个暴力的复杂度</p>
<p>不过第一条暴力对下文确实没啥关联，因为我们的操作分块是对第二个暴力做平衡。</p>
<p>直白地说，如果你第一个暴力的修改是 $O(k)​$ 的，对应的第二个暴力的复杂度是 $O(nk)​$ 的，如果 $k​$ 很大，你怎么分块平衡它。</p>
<h2 id="2025-7-5"><a href="#2025-7-5" class="headerlink" title="2025.7.5"></a>2025.7.5</h2><p>hash+kmp+Manacher</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>前面一个小时被 hash 各种创飞……</p>
<h3 id="PAL-Palindromes"><a href="#PAL-Palindromes" class="headerlink" title="PAL-Palindromes"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3449">PAL-Palindromes</a></h3><p>发现如果 AB 是可行解的话，那么 BA 也是可行解。</p>
<p>令 a 的哈希值为 a，长度为 lena，b 的哈希值为 b，长度为 lenb。</p>
<p>所以有 $a\times p^{lenb}+b&#x3D;b\times p^{lena}+a$</p>
<p>移项，然后可以得到 $\frac{a}{p^{lena}-1}&#x3D;\frac{b}{p^{lenb}-1}$</p>
<p>把这个扔进桶里，计数即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;bits/extc++.h&gt;
#define ll long long
using namespace std;
using namespace __gnu_pbds;
int n,l;
string s;
ll ans;
constexpr int P=131,p1=998244353,p2=1e9+7;
int qpow(int a,int b,const int &amp;p)&#123;
    int res=1;
    while(b)&#123;
        if(b&amp;1) res=(ll)res*a%p;
        b&gt;&gt;=1,a=(ll)a*a%p;
    &#125;
    return res;
&#125;
int hash1(const string &amp;s)&#123;
    ll a=0,b=1;
    for(char ch:s)&#123;
        b=b*P%p1;
        a=(a*P+ch)%p1;
    &#125;
    return a*qpow(b-1,p1-2,p1)%p1;
&#125;
int hash2(const string &amp;s)&#123;
    ll a=0,b=1;
    for(char ch:s)&#123;
        b=b*P%p2;
        a=(a*P+ch)%p2;
    &#125;
    return a*qpow(b-1,p2-2,p2)%p2;
&#125;
struct pair_hash&#123;
    size_t operator()(const pair&lt;int,int&gt; &amp;x)const&#123;
        size_t seed=0;
        seed^=hash&lt;int&gt;&#123;&#125;(x.first)+0x9e3779b9+(seed&lt;&lt;6)+(seed&gt;&gt;2);
        seed^=hash&lt;int&gt;&#123;&#125;(x.second)+0x9e3779b9+(seed&lt;&lt;6)+(seed&gt;&gt;2);
        return seed;
    &#125;
&#125;;
gp_hash_table&lt;pair&lt;int,int&gt;,int,pair_hash&gt; mp;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;l&gt;&gt;s;
        ans+=mp[make_pair(hash1(s),hash2(s))]++;
    &#125;
    cout &lt;&lt; 2*ans+n;
    return 0;
&#125;
</code></pre>
<h3 id="OKR-A-Horrible-Poem"><a href="#OKR-A-Horrible-Poem" class="headerlink" title="OKR-A Horrible Poem"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3538#submit">OKR-A Horrible Poem</a></h3><p>周期要求是恰好匹配的，所以对于一个长度的因数是较小的，粗略是根号的。</p>
<p>所以线性筛，筛出所有质因数，然后直接分解枚举所有长度就行。</p>
<p>复杂度是 $q\sqrt n$ ，不知道咋能过的。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define ull unsigned long long
using namespace std;
constexpr int N = 5e5+10;
constexpr int base = 37;
vector&lt;int&gt; pri;
bool prime[N];
int g[N];
ull table[N],fac[N];
void init()&#123;
    for(int i=2;i&lt;=5e5+1;i++)&#123;
        if(!prime[i])&#123;
            pri.push_back(i);
            g[i]=i;
        &#125;
        for(int p:pri)&#123;
            if(p*i&gt;5e5+1) break;
            prime[i*p]=1;
            g[p*i]=p;
            if(i%p==0) break;
        &#125;
    &#125;
&#125;
int n,m,ans,len;
string s;
int query(int l,int r)&#123;
    return table[r]-table[l-1]*fac[r-l+1];
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    init();
    cin&gt;&gt;n&gt;&gt;s;s=&#39; &#39;+s;
    fac[0]=1;
    for(int i=1;i&lt;=n;i++)&#123;
        table[i]=table[i-1]*base+s[i]-&#39;a&#39;+1;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        fac[i]=base*fac[i-1];
    &#125;
    cin&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        ans=len=r-l+1;
        while(len&gt;1)&#123;
            if(query(l+ans/g[len],r)==query(l,r-ans/g[len]))
                ans/=g[len];
            len/=g[len];
        &#125;
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    &#125;
    
    return 0;
&#125;
</code></pre>
<h3 id="等差子序列"><a href="#等差子序列" class="headerlink" title="等差子序列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2757#submit">等差子序列</a></h3><p>发现如果在权值的角度看，不满足条件的情况只有插入一个值时，值的两侧是回文串。</p>
<p>那么把哈希值扔权值线段树上维护一下，维护从左至右和从右至左两种hash值，直接比对就行。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N=5e5+10;
const int base=13331;
const int p=1e9+7;
int T,n,a[N];
ll pw[N];
struct Tree&#123;
    #define ls u&lt;&lt;1
    #define rs u&lt;&lt;1|1
    ll tr[N&lt;&lt;2][2];
    ll len=0;
    void init()&#123;
        memset(tr,0,sizeof(tr));
    &#125;
    void pushup(int u,int l,int r)&#123;
        int mid=(l+r)&gt;&gt;1;
        tr[u][0]=(tr[ls][0]*pw[r-mid]%p+tr[rs][0])%p;
        tr[u][1]=(tr[ls][1]+tr[rs][1]*pw[mid-l+1]%p)%p;
    &#125;
    void update(int u,int l,int r,int x)&#123;
        if(l==r)&#123;
            tr[u][0]=tr[u][1]=1;
            return ;
        &#125;
        int mid=(l+r)&gt;&gt;1;
        if(x&lt;=mid) update(ls,l,mid,x);
        else update(rs,mid+1,r,x);
        pushup(u,l,r);
    &#125;
    ll query(int u,int l,int r,int x,int y,int opt)&#123;
        ll res=0;
        if(l&gt;=x &amp;&amp; r&lt;=y)&#123;
            res=(res+tr[u][opt]*pw[len]%p)%p;
            len+=(r-l+1);
            return res;
        &#125;
        int mid=(l+r)&gt;&gt;1;
        if(opt==0)&#123;
            if(mid&lt;y) res=(res+query(rs,mid+1,r,x,y,opt))%p;
            if(x&lt;=mid) res=(res+query(ls,l,mid,x,y,opt))%p;
        &#125;else&#123;
            if(x&lt;=mid) res=(res+query(ls,l,mid,x,y,opt))%p;
            if(mid&lt;y) res=(res+query(rs,mid+1,r,x,y,opt))%p;
        &#125;
        return res;
    &#125;
&#125;Tr;
int main()&#123;
    cin&gt;&gt;T;
    pw[0]=1;
    for(int i=1;i&lt;=5e5;i++)&#123;
        pw[i]=pw[i-1]*base%p;
    &#125;
    while(T--)&#123;
        cin&gt;&gt;n;
        for(int i=1;i&lt;=n;i++)&#123;
            cin&gt;&gt;a[i];
        &#125;
        bool f=false;
        for(int i=1;i&lt;=n;i++)&#123;
            Tr.update(1,1,n,a[i]);
            int l=min(a[i],n-a[i]+1);
            Tr.len=0;
            ll res1=Tr.query(1,1,n,a[i]-l+1,a[i]+l-1,0);
            Tr.len=0;
            ll res2=Tr.query(1,1,n,a[i]-l+1,a[i]+l-1,1);
            if(res1!=res2)&#123;
                f=true;
                break;
            &#125;
        &#125;
        if(f) cout &lt;&lt; &quot;Y\n&quot;;
        else cout &lt;&lt; &quot;N\n&quot;;
        Tr.init();
    &#125;
    
    return 0;
&#125;
</code></pre>
<h3 id="Tasowanie"><a href="#Tasowanie" class="headerlink" title="Tasowanie"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8023">Tasowanie</a></h3><p>二分+hash</p>
<p>去二分下一个不同的位置的hash，判断大小，然后贪心即可。</p>
<p>但这个太不优雅了，我们选择更自然地方法：后缀数组。</p>
<p>后缀数组能维护每一个后缀的排名，刚好是我们需要的信息。</p>
<p>中间分割两个字符串的要是大于字符集的，要不然就加到序列里去了。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 4e5+10;
int n,m;
struct SufArr&#123;
    int x[N],y[N],s[N],cnt[N],sa[N],rk[N],len;
    void build()&#123;
        for(int i=1;i&lt;=len;i++)&#123;
            x[i]=s[i];
            cnt[x[i]]++;
        &#125;
        for(int i=2;i&lt;=3001;i++)&#123;
            cnt[i]+=cnt[i-1];
        &#125;
        for(int i=len;i&gt;=1;i--)&#123;
            sa[cnt[x[i]]--]=i;
        &#125;
        for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123;
            int num=0;
            for(int i=len-k+1;i&lt;=len;i++)&#123;
                y[++num]=i;
            &#125;
            for(int i=1;i&lt;=len;i++)&#123;
                if(sa[i]&gt;k)&#123;
                    y[++num]=sa[i]-k;
                &#125;
            &#125;
            for(int i=1;i&lt;=m;i++) cnt[i]=0;
            for(int i=1;i&lt;=len;i++) cnt[x[i]]++;
            for(int i=2;i&lt;=m;i++) cnt[i]+=cnt[i-1];
            for(int i=len;i&gt;=1;i--)&#123;
                sa[cnt[x[y[i]]]--]=y[i];
                y[i]=0;
            &#125;
            swap(x,y);
            x[sa[1]]=1,num=1;
            for(int i=2;i&lt;=len;i++)
                x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num;
            if(num==len) break;
            m=num;
        &#125;
        for(int i=1;i&lt;=len;i++)&#123;
            rk[sa[i]]=i;
        &#125;
    &#125;
&#125;SA;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;SA.s[i];
    &#125;
    cin&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;SA.s[i+n+1];
    &#125;
    SA.s[1+n]=3001;
    SA.s[2+m+n]=3001;
    SA.len=n+m+2;
    SA.build();
    int id1=1,id2=n+2;
    for(int i=1;i&lt;SA.len;i++)&#123;
        if(SA.rk[id1]&lt;SA.rk[id2])&#123;cout &lt;&lt; SA.s[id1] &lt;&lt; &#39; &#39;;id1++;&#125;
        else &#123;cout &lt;&lt; SA.s[id2] &lt;&lt;&#39; &#39;;id2++;&#125;
        if(id1==n+1)&#123;
            for(int j=id2;j&lt;SA.len;j++)&#123;
                cout &lt;&lt; SA.s[j] &lt;&lt; &#39; &#39;;
            &#125;break;
        &#125;
        if(id2==SA.len+1)&#123;
            for(int j=id1;j&lt;=n;j++)&#123;
                cout &lt;&lt; SA.s[j] &lt;&lt; &#39; &#39;;
            &#125;break;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>headless_piston 的 hash+二分 跑到最优解了？我直接贺一个 $O(n)​$ 的后缀数组来！</p>
<p>常数太大，仍旧跑不过……</p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><h3 id="String-Set-Queries"><a href="#String-Set-Queries" class="headerlink" title="String Set Queries"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF710F">String Set Queries</a></h3><p>不知道把这个扔这里合不合适啊。</p>
<p>题解是 启发式合并AC自动机  <del>我瞎取的</del></p>
<p>就是把删除的串扔进新的 AC 自动机，利用 AC 自动机可减性。</p>
<p>当两个AC自动机大小相同时，暴力合并。</p>
<p>全局最多 $\log m$ 个AC自动机，复杂度可以接受。</p>
<p>但这显然不是我们想要的。</p>
<p>我们发现关键性质：字符串总长不超过 3e5。</p>
<p>对于所有字符串，大于 $\sqrt n$ 的只有 $\sqrt n$ 个，而小于 $\sqrt n$ 的我们能接受直接遍历。</p>
<p>所以！将小于 $\sqrt n$ 的扔 Trie 上，大于 $\sqrt n$ 的挨个 KMP 一下。</p>
<p>那么本题我们就用优美的根号分治做完了。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 3e5+10;
int n;
struct Trie&#123;
    struct node&#123;
        int son[26];
        int cnt;
    &#125;tr[N];
    int tot=0;
    void insert(char *s,int val)&#123;
        int u=0;
        for(int i=0;s[i];i++)&#123;
            char ch=s[i];
            int &amp;son=tr[u].son[ch-&#39;a&#39;];
            if(!son) son=++tot;
            u=son;
        &#125;
        tr[u].cnt+=val;
    &#125;
    int query(char *s)&#123;
        int u=0,res=0;
        for(int i=0;s[i];i++)&#123;
            int c=s[i]-&#39;a&#39;;
            if(!tr[u].son[c]) break;
            u=tr[u].son[c];
            res+=tr[u].cnt;
        &#125;
        return res;
    &#125;
&#125;T;
struct KMP&#123;
    int nxt[N];
    void build(const string &amp;s,int len)&#123;
        memset(nxt,0,sizeof(nxt));
        int i=0,j=-1;nxt[0]=-1;
        while(i&lt;len)&#123;
            if(j==-1 || s[i]==s[j]) nxt[++i]=++j;
            else j=nxt[j];
        &#125;
    &#125;
    int query(string s,char *qry)&#123;
        int res=0;
        int lens=s.size(),len=strlen(qry);
        build(s,s.size());
        for(int i=0,j=0;i&lt;len;i++)&#123;
            while(j&gt;0 &amp;&amp; qry[i]!=s[j]) j=nxt[j];
            if(qry[i]==s[j]) j++;
            if(j==lens)&#123;
                res++;
                j=nxt[j];
            &#125;
        &#125;
        return res;
    &#125;
&#125;kmp;
string que[50];
char s[N];
int cnt,val[50];
int main()&#123;
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1,op;i&lt;=n;i++)&#123;
        scanf(&quot;%d%s&quot;,&amp;op,s);
        int len=strlen(s);
        if(op==1 || op==2)&#123;
            int v=(op==1 ? 1 : -1);
            if(len&lt;=1000)&#123;
                T.insert(s,v);
            &#125;else&#123;
                que[cnt]=string(s);
                val[cnt++]=v;
            &#125;
        &#125;else&#123;
            ll ans=0;
            for(int i=0;i&lt;len;i++)&#123;
                ans+=T.query(s+i);
            &#125;
            for(int i=0;i&lt;cnt;i++)&#123;
                if(que[i].length()&gt;len) continue;
                ans+=kmp.query(que[i],s)*val[i];
            &#125;
            printf(&quot;%lld\n&quot;,ans);
            fflush(stdout);
        &#125;
    &#125;
    
    return 0;
&#125;
</code></pre>
<h3 id="SZA-Template"><a href="#SZA-Template" class="headerlink" title="SZA-Template"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3426">SZA-Template</a></h3><p>我们定义 $f_i$ 表示第 $i$ 个位置至少需要多长的印章。</p>
<p>发现我们只有两种转移：$f_i&#x3D;i$ 或者 $f_i&#x3D;f_{nxt_i}$</p>
<p>要么全印了，要么之前有一个 nxt 可以覆盖到。</p>
<p>第二个取到的条件 $i_{nxt_i}\to i$ 中有值，所以开个桶，看看能不能覆盖到即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 5e5+10;
string s;
int n,f[N],vis[N],nxt[N];
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;s;
    s=&#39; &#39;+s;
    n=s.length()-1;
    for(int i=2,j=0;i&lt;=n;i++)&#123;
        while(j&gt;0 &amp;&amp; s[j+1]!=s[i]) j=nxt[j];
        if(s[j+1]==s[i]) j++;
        nxt[i]=j;
    &#125;
    f[1]=1;vis[1]=1;
    for(int i=2;i&lt;=n;i++)&#123;
        f[i]=i;
        if(vis[f[nxt[i]]]&gt;=i-nxt[i]) f[i]=f[nxt[i]];
        vis[f[i]]=i;
    &#125;
    cout &lt;&lt; f[n];
    return 0;
&#125;
</code></pre>
<h3 id="GT考试"><a href="#GT考试" class="headerlink" title="GT考试"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3193">GT考试</a></h3><p>我们定义 $f_{i,j}$ 表示在第 $i$ 个位置上匹配的串长度变成 $j$ 的方案数。</p>
<p>然后定义 $g_{k,j}$ 表示从长度为 $k$ 的匹配串变成长度为 $j$ 的匹配串的方案数。</p>
<p>有转移：$f_{i,j}&#x3D;\sum_{k&#x3D;0}^{m-1}f_{i-1,k}\times g_{k,j}$</p>
<p>$g$ 可以用 KMP 求出。</p>
<p>然后发现是矩阵，直接上快速幂优化一下即可。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define ll long long
using namespace std;
const int N=25;
int n,m,p;
char s[N];
int nxt[N];
int ans=0;

void update(int &amp;x,int y)&#123;
    x+=y;
    while(x&gt;=p) x-=p;
&#125;
struct node&#123;
    int n,a[N][N];
    node(int m=0)&#123;n=m,memset(a,0,sizeof(a));&#125;
    void operator ! ()&#123;
        for(int i=0;i&lt;n;i++) a[i][i]=1;  
    &#125;
    node operator * (const node &amp;b) const&#123;
        node res(n);
        for(int i=0;i&lt;n;i++)&#123;
            for(int j=0;j&lt;n;j++)&#123;
                for(int k=0;k&lt;n;k++)&#123;
                    update(res.a[i][k],1ll*a[i][j]*b.a[j][k]%p);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
    node operator ^ (ll b) const&#123;
        node ret(n),x=*this;!ret;
        for(ll p=b;p;p&gt;&gt;=1,x=x*x) if(p&amp;1) ret=ret*x;
        return ret;
    &#125;
&#125;;
node kmp()&#123;
    nxt[1]=0;
    int j=0;
    for(int i=2;i&lt;=m;i++)&#123;
        while(j&gt;0 &amp;&amp; s[j+1]!=s[i]) j=nxt[j];
        if(s[j+1]==s[i]) j++;
        nxt[i]=j;
    &#125;
    node res(m);
    for(int i=0;i&lt;m;i++)&#123;
        for(char c=&#39;0&#39;;c&lt;=&#39;9&#39;;c++)&#123;
            int j=i;
            while(j &amp;&amp; s[j+1]!=c) j=nxt[j];
            if(s[j+1]==c) ++j;
            res.a[i][j]++;
        &#125;
    &#125;
    return res;
&#125;
void print(node res)&#123;
    for(int i=0;i&lt;m;i++)&#123;
        for(int j=0;j&lt;m;j++)&#123;
            cout&lt;&lt;res.a[i][j]&lt;&lt;&#39; &#39;;
        &#125;cout&lt;&lt;&#39;\n&#39;;
    &#125;
&#125;
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;s[i];
    &#125;
    node a=kmp();
    a=a^n;
//	print(a);
    for(int i=0;i&lt;m;i++) update(ans,a.a[0][i]);
    cout&lt;&lt;ans;
    return 0;
&#125;
</code></pre>
<h3 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h3><h3 id="拉拉队排练"><a href="#拉拉队排练" class="headerlink" title="拉拉队排练"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1659#submit">拉拉队排练</a></h3><p>因为要求奇回文串，所以不添加额外字符做 Manacher 即可。</p>
<p>然后拿个桶计数，倒着扫一遍然后快速幂一下。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
constexpr int N = 1e6+10;
constexpr int p = 19930726;
ll n,pos[N&lt;&lt;1],vis[N&lt;&lt;1];
ll sum,ans=1,k;
string s;
ll qpow(ll a,ll b)&#123;
    ll res=1;
    while(b)&#123;
        if(b&amp;1) res=res*a%p;
        b&gt;&gt;=1;a=a*a%p;
    &#125;
    return res;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;
    s=&#39; &#39;+s;
    for(ll i=1,r=0,mid=0;i&lt;(int)s.length();i++)&#123;
        if(i&lt;=r) pos[i]=min(pos[mid*2-i],r-i);
        while(s[i-pos[i]]==s[i+pos[i]]) ++pos[i];
        if(pos[i]+i-1&gt;r) r=pos[i]+i-1,mid=i;
        vis[pos[i]*2-1]++;
    &#125;
    if(n%2==0) n--;
    for(ll i=n;i&gt;=1;i-=2)&#123;
        sum+=vis[i];
        if(sum&gt;k)&#123;
            ans=ans*qpow(i,k)%p;
            break;
        &#125;else&#123;
            ans=ans*qpow(i,sum)%p;
            k-=sum;
        &#125;
    &#125;
    if(sum&lt;k) cout &lt;&lt; -1;
    else cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<h3 id="最长双回文串"><a href="#最长双回文串" class="headerlink" title="最长双回文串"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4555">最长双回文串</a></h3><p>Manacher 的时候记一下以 $i$ 为左端点的最长回文串和以 $i$ 为右端点的最长回文串。</p>
<p>最后答案就是这俩拼起来。</p>
<p>Manacher 的途中跟随统计一下就行。</p>
<p>最后需要在重新扫一遍。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define B 600
using namespace std;
const int N = 3e5+10;
char s[N&lt;&lt;1];
int cnt,pos[N];
int nl[N],nr[N],ans;
void read()&#123;
    char c=getchar();
    s[0]=&#39;!&#39;;
    s[++cnt]=&#39;#&#39;;
    while(c&lt;&#39;a&#39; || c&gt;&#39;z&#39;) c=getchar();
    while(c&gt;=&#39;a&#39; &amp;&amp; c&lt;=&#39;z&#39;)&#123;
        s[++cnt]=c;
        s[++cnt]=&#39;#&#39;;
        c=getchar();
    &#125;
    s[++cnt]=&#39;$&#39;;
&#125;
void manacher()&#123;
    for(int i=1,r=0,mid=0;i&lt;=cnt;i++)&#123;
        if(i&lt;r) pos[i]=min(pos[mid*2-i],r-i);
        else pos[i]=1;
        while(s[i-pos[i]]==s[i+pos[i]]) ++pos[i];
        if(pos[i]+i&gt;r) r=pos[i]+i,mid=i;
        nr[i+pos[i]-1] = max(nr[i+pos[i]-1],pos[i]-1);
        nl[i-pos[i]+1] = max(nl[i-pos[i]+1],pos[i]-1);
    &#125;
&#125;
int main()&#123;
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0); 
    read();
    manacher();
    for(int i=cnt;i&gt;=1;i-=2) nr[i]=max(nr[i],nr[i+2]-2);
    for(int i=1;i&lt;=cnt;i+=2) nl[i]=max(nl[i],nl[i-2]-2);
    for(int i=1;i&lt;=cnt;i+=2) if(nl[i]&amp;&amp;nr[i]) ans=max(ans,nl[i]+nr[i]);
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<h2 id="2025-7-6"><a href="#2025-7-6" class="headerlink" title="2025.7.6"></a>2025.7.6</h2><p>搜索专题</p>
<p>不想写了，感觉有用的也就 Astar 和 折半搜索。</p>
<p>觉得考场上有这个思想就很好了，别说写了，都不知道啥时候考。</p>
<p>各种剪枝技巧也没法扩展啊，还是重在思想吧。</p>
<p>给 dbg 学长都讲无语了。</p>
<p><strong>所以我拒绝了吃屎，选择学习：扫描线</strong></p>
<h2 id="2025-7-7"><a href="#2025-7-7" class="headerlink" title="2025.7.7"></a>2025.7.7</h2><p>今天就当没发生过，我也没在今天活着。</p>
<h2 id="2025-7-8"><a href="#2025-7-8" class="headerlink" title="2025.7.8"></a>2025.7.8</h2><p>最小生成树+拓扑+最短路</p>
<h3 id="P3645-雅加达的摩天楼"><a href="#P3645-雅加达的摩天楼" class="headerlink" title="P3645 雅加达的摩天楼"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3645">P3645 雅加达的摩天楼</a></h3><p>最短路，但是没有用到除 BFS 以外的任何算法。</p>
<p>直接连边然后 01 BFS 肯定炸空间，那么不连边只保留状态（用bitset）。</p>
<p>发现我们做完了。其实是根号分治，具体分析可以参考我 根号算法 那篇文章。</p>
<h3 id="P4180-严格次小生成树"><a href="#P4180-严格次小生成树" class="headerlink" title="P4180 严格次小生成树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4180">P4180 严格次小生成树</a></h3><p>先最小生成树，然后尝试替换掉某一条树边。</p>
<p>发现只保留最大值是不够的，还需要保留次大值。</p>
<p>无修改，所以倍增维护一下最大值和次大值即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define inf 2e9
using namespace std;
const int N = 1e5+10;
int n,m,fa[N];
ll sum,ans=1e18;
int find(int x)&#123;return fa[x]==x ? x : fa[x]=find(fa[x]);&#125;
struct Edge&#123;
    int u,v,w;
    bool operator &lt;(const Edge &amp;a)const&#123;
        return w&lt;a.w;
    &#125;
&#125;e[N&lt;&lt;3];
bool vis[N&lt;&lt;3];
struct node&#123;
    int v,w;
&#125;;
vector&lt;node&gt; G[N];
void Kruskal()&#123;
    for(int i=1;i&lt;=n;i++) fa[i]=i;
    sort(e+1,e+1+m);
    for(int i=1;i&lt;=m;i++)&#123;
        int x=e[i].u,y=e[i].v;
        int fx=find(x),fy=find(y);
        if(fx==fy) continue;
        sum+=e[i].w;vis[i]=1;
        G[e[i].u].push_back(&#123;e[i].v,e[i].w&#125;);
        G[e[i].v].push_back(&#123;e[i].u,e[i].w&#125;);
        fa[fy]=fx;
    &#125;
&#125;
int f[N][30],g[N][30],h[N][30],dep[N];
void dfs(int u,int father,int w)&#123;
    dep[u]=dep[father]+1;
    f[u][0]=father;
    g[u][0]=w;h[u][0]=-inf;
    for(int i=1;i&lt;=20;i++)&#123;
        f[u][i]=f[f[u][i-1]][i-1];
        g[u][i]=max(g[u][i-1],g[f[u][i-1]][i-1]);
        h[u][i]=max(h[u][i-1],h[f[u][i-1]][i-1]);
        if(g[u][i-1]&gt;g[f[u][i-1]][i-1]) h[u][i]=max(h[u][i],g[f[u][i-1]][i-1]);
        else if(g[u][i-1]&lt;g[f[u][i-1]][i-1]) h[u][i]=max(h[u][i],g[u][i-1]);
    &#125;
    for(auto to:G[u])&#123;
        int v=to.v,w=to.w;
        if(v==father) continue;
        dfs(v,u,w);
    &#125;
&#125;
int LCA(int x,int y)&#123;
    if(dep[x]&lt;dep[y]) swap(x,y);
    for(int i=19;i&gt;=0;i--)&#123;
        if(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];
    &#125;
    if(x==y) return x;
    for(int i=19;i&gt;=0;i--)&#123;
        if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    &#125;
    return f[x][0];
&#125;
int qmax(int x,int y,int mx)&#123;
    int res=-inf;
    for(int i=19;i&gt;=0;i--)&#123;
        if(dep[f[x][i]]&gt;=dep[y])&#123;
            if(g[x][i]!=mx) res=max(res,g[x][i]);
            else res=max(res,h[x][i]);
            x=f[x][i];
        &#125;
    &#125;
    return res;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v,w;i&lt;=m;i++)&#123;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        e[i]=&#123;u,v,w&#125;;
    &#125;
    Kruskal();
    dfs(1,0,0);
    for(int i=1;i&lt;=m;i++)&#123;
        if(vis[i]) continue;
        int u=e[i].u,v=e[i].v,w=e[i].w;
        int lca=LCA(u,v);
        int mx1=qmax(u,lca,w);
        int mx2=qmax(v,lca,w);
        ans=min(ans,sum-max(mx1,mx2)+w);
    &#125;
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<h3 id="P4197-Peaks"><a href="#P4197-Peaks" class="headerlink" title="P4197 Peaks"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4197">P4197 Peaks</a></h3><p>Tips：主席树开 32 倍空间及以上，变量名避免使用 tr 和 rt……</p>
<p>Kruskal 重构树。</p>
<p>边权从小到大排序，然后重构树。一棵子树的所有叶子节点都是能到达的山。</p>
<p>所以考虑倍增维护一下最高能到哪个节点，然后主席树维护区间第 k 大值即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define N 100010
#define M 500010
using namespace std;
int n,m,q,h[N],b[N];
struct Edge&#123;
    int u,v,w;
    bool operator &lt; (const Edge &amp;a)const&#123;
        return w&lt;a.w;
    &#125;
&#125;e[M];
int val[N&lt;&lt;1],fa[N&lt;&lt;1],tot;
int find(int x)&#123;return fa[x]==x ? x : fa[x]=find(fa[x]);&#125;
vector&lt;int&gt; G[N&lt;&lt;1];
int f[N&lt;&lt;1][30];
void kruskal()&#123;
    for(int i=1;i&lt;=2*n;i++) fa[i]=i;
    sort(e+1,e+1+m);tot=n;
    for(int i=1;i&lt;=m;i++)&#123;
        int fx=find(e[i].u),fy=find(e[i].v);
        if(fx==fy) continue;
        fa[fx]=fa[fy]=++tot;
        G[tot].push_back(fx);G[tot].push_back(fy);
        f[fx][0]=f[fy][0]=tot;val[tot]=e[i].w;
    &#125;
&#125;
int ls[N&lt;&lt;5],rs[N&lt;&lt;5],rt[N&lt;&lt;5],tr[N&lt;&lt;5],cnt,num,len,L[N&lt;&lt;1],R[N&lt;&lt;1];
void update(int &amp;now,int pre,int l,int r,int x)&#123;
    if(!now) now=++cnt;tr[now]=tr[pre]+1;
    if(l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if(x&lt;=mid)&#123;rs[now]=rs[pre];update(ls[now],ls[pre],l,mid,x);&#125;
    else&#123;ls[now]=ls[pre];update(rs[now],rs[pre],mid+1,r,x);&#125;
&#125;
int query(int u,int lim,int k)&#123;
    int l=1,r=len;
    for(int i=19;i&gt;=0;i--)&#123;
        if(f[u][i] &amp;&amp; val[f[u][i]]&lt;=lim) u=f[u][i];
    &#125;
    int x=rt[L[u]-1],y=rt[R[u]];
    if(tr[y]-tr[x]&lt;k) return -1;
    while(l&lt;r)&#123;
        int tmp=tr[rs[y]]-tr[rs[x]];
        int mid=(l+r)&gt;&gt;1;
        if(tmp&gt;=k) x=rs[x],y=rs[y],l=mid+1;
        else x=ls[x],y=ls[y],r=mid,k-=tmp;
    &#125;
    return b[r];
&#125;
void dfs(int u)&#123;
    for(int i=1;i&lt;=20;i++)&#123;
        f[u][i]=f[f[u][i-1]][i-1];
    &#125;
    L[u]=++num;
    if(u&lt;=n) update(rt[num],rt[num-1],1,len,h[u]);
    else rt[num]=rt[num-1];
    for(int v:G[u]) dfs(v);
    R[u]=num;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
    for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;h[i];b[i]=h[i];&#125;
    for(int i=1;i&lt;=m;i++)&#123;
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        e[i]=&#123;u,v,w&#125;;
    &#125;
    sort(b+1,b+1+n);
    len=unique(b+1,b+1+n)-b-1;
    for(int i=1;i&lt;=n;i++)&#123;h[i]=lower_bound(b+1,b+1+len,h[i])-b;&#125;
    kruskal();
    for(int i=1;i&lt;=tot;i++) if(!L[i]) dfs(find(i));
    for(int i=1,u,x,k;i&lt;=q;i++)&#123;
        cin&gt;&gt;u&gt;&gt;x&gt;&gt;k;
        cout &lt;&lt; query(u,x,k) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="P2272-最大半连通子图"><a href="#P2272-最大半连通子图" class="headerlink" title="P2272 最大半连通子图"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2272">P2272 最大半连通子图</a></h3><p>Trick：tarjan 缩点后的序列编号是逆序拓扑。</p>
<p>为数不多的码量较小的题。</p>
<p>先缩点然后变成 DAG。</p>
<p>DAG 上 dp 找 最长链就是对的。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 1e5+10;
int n,m,p;
vector&lt;int&gt; G1[N],G2[N];
int dfn[N],dfx,low[N],scc,bel[N],siz[N];
bool vis[N];
stack&lt;int&gt; sta;
void tarjan(int u)&#123;
    dfn[u]=low[u]=++dfx;
    vis[u]=1;sta.push(u);
    for(int v:G1[u])&#123;
        if(!dfn[v])&#123;
            tarjan(v);
            low[u]=min(low[u],low[v]);
        &#125;else if(vis[v])&#123;
            low[u]=min(low[u],dfn[v]);
        &#125;
    &#125;
    if(low[u]==dfn[u])&#123;
        scc++;
        while(sta.top()!=u)&#123;
            int t=sta.top();sta.pop();
            vis[t]=0;
            bel[t]=scc;
            siz[scc]++;
        &#125;
        vis[u]=0;bel[u]=scc;siz[scc]++;sta.pop();
    &#125;
&#125;
int f[N],g[N],use[N],ans1,ans2;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;
    for(int i=1,u,v;i&lt;=m;i++)&#123;
        cin&gt;&gt;u&gt;&gt;v;
        G1[u].push_back(v);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(!dfn[i]) tarjan(i);
    &#125;
    for(int u=1;u&lt;=n;u++)&#123;
        f[u]=siz[u];g[u]=1;
        for(int v:G1[u])&#123;
            if(bel[u]==bel[v]) continue;
            G2[bel[u]].push_back(bel[v]);
        &#125;
    &#125;
    for(int u=scc;u&gt;=1;u--)&#123;
        for(int v:G2[u])&#123;
            if(use[v]==u) continue;
            use[v]=u;
            if(f[v]&lt;f[u]+siz[v])&#123;
                f[v]=f[u]+siz[v];
                g[v]=g[u];
            &#125;else if(f[v]==f[u]+siz[v])&#123;
                g[v]+=g[u];
                g[v]%=p;
            &#125;
        &#125;
    &#125;
    for(int i=1;i&lt;=scc;i++)&#123;
        if(f[i]&gt;ans1)&#123;
            ans1=f[i];
            ans2=g[i];
        &#125;else if(f[i]==ans1)&#123;
            ans2+=g[i];
            ans2%=p;
        &#125;
    &#125;
    cout &lt;&lt; ans1&lt;&lt;&#39;\n&#39;&lt;&lt;ans2;
    return 0;
&#125;
</code></pre>
<h2 id="2025-7-9"><a href="#2025-7-9" class="headerlink" title="2025.7.9"></a>2025.7.9</h2><p>今天不打算写太多题了，想写写笔记整理一下。</p>
<h3 id="P4819-杀人游戏"><a href="#P4819-杀人游戏" class="headerlink" title="P4819 杀人游戏"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4819">P4819 杀人游戏</a></h3><p>缩点后 DAG 上询问入度为 0 的点显然正确。</p>
<p>但是有特殊情况：如果有一个入度为 0 的孤点，我们就没必要去询问他。</p>
<p>因为我们可以使用排除法给它排除掉。<del>所以这为啥是紫？</del></p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N=3e5+10;
int n,m;
map&lt;pair&lt;int,int&gt;,bool&gt; mp;
vector&lt;int&gt; vec[N];
vector&lt;int&gt; G[N];
int low[N],dfn[N],tot,cnt,scc[N],siz[N],in[N];
stack&lt;int&gt; sta;
struct Edge&#123;
    int u,v;
&#125;e[N];
bool vis[N];
void tarjan(int u)&#123;
    low[u]=dfn[u]=++tot;
    vis[u] = 1;
    sta.push(u);
    for(int v:vec[u])&#123;
        if(!dfn[v])&#123;
            tarjan(v);
            low[u]=min(low[u],low[v]);
        &#125;else if(vis[v])&#123;
            low[u]=min(low[u],dfn[v]);
        &#125;
    &#125;
    if(low[u]==dfn[u])&#123;
        cnt++;
        // vis[u]=0;
        // scc[u]=cnt;
        // siz[cnt]++;
        while(sta.top()!=u)&#123;
            scc[sta.top()]=cnt;
            vis[sta.top()]=0;
            siz[cnt]++;
            sta.pop();
        &#125;
        vis[u]=0;
        scc[u]=cnt;
        siz[cnt]++;
        sta.pop();
    &#125;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        e[i].u=u,e[i].v=v;
        if(mp[make_pair(u,v)]) continue;
        mp[make_pair(u,v)]=1;
        vec[u].push_back(v);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(!dfn[i])&#123;
            tarjan(i);
        &#125;
    &#125;
    mp.clear();
    for(int i=1;i&lt;=m;i++)&#123;
        int u=scc[e[i].u],v=scc[e[i].v];
        if(u!=v)&#123;
            if(mp[make_pair(u,v)]) continue;
            mp[make_pair(u,v)]=1;
            G[u].push_back(v);
            in[v]++;
        &#125;
    &#125;
    double ans=0;
    for(int i=1;i&lt;=cnt;i++)&#123;
        if(in[i]==0) ans++;
    &#125;
    for(int i=1;i&lt;=cnt;i++)&#123;
        if(in[i]==0 &amp;&amp; siz[i]==1)&#123;
            bool f=true;
            for(int v:G[i])&#123;
                if(in[v]&lt;=1)&#123;
                    f=false;
                    break;
                &#125;
            &#125;
            if(f)&#123;
                ans--;
                break;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;(1.0-ans/(1.0*n));
    return 0;
&#125;
</code></pre>
<h2 id="本阶段总结"><a href="#本阶段总结" class="headerlink" title="本阶段总结"></a>本阶段总结</h2><p>就以不同学长讲课划分阶段吧。</p>
<p>第一阶段的学长是：Acestar 学长。让我们感谢学长的陪伴与教导。</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>单调队列优化dp+并查集+字符串+数据结构+图论+搜索。<del>怎么还在讲搜索啊？！</del></p>
<p>感觉学了很多题，也有很多新 trick，收获最大的可能就是根号分治的相关内容吧。</p>
<p>下次做题一定先想根号复杂度。</p>
<h2 id="2025-7-10"><a href="#2025-7-10" class="headerlink" title="2025.7.10"></a>2025.7.10</h2><p>放假了，宅家打了一上午洲和一下午第五人格。</p>
<p>空调开着太潮了，关了太热了。</p>
<p>还没过崩铁新剧情。</p>
<h2 id="2025-7-11"><a href="#2025-7-11" class="headerlink" title="2025.7.11"></a>2025.7.11</h2><p>回来就是模拟赛，撒尼姆啊？</p>
<p>T1 是奇妙栈题，下次得多考虑这些奇妙的东西了。</p>
<p>T2 是树形 dp，没看出来，确实还得多练。</p>
<p>T3 是概率计数，根本不会啊。</p>
<p>T4 是边分治+李超树维护斜率。</p>
<p>题单没做，一道题是规程。</p>
<h2 id="2025-7-12"><a href="#2025-7-12" class="headerlink" title="2025.7.12"></a>2025.7.12</h2><p>扫描线啊，根本不会啊。做的全是原题，就不在此赘述了。</p>
<p>晚上没教练，高强度刷知乎半个晚自习。</p>
<h2 id="2025-7-13"><a href="#2025-7-13" class="headerlink" title="2025.7.13"></a>2025.7.13</h2><p>树上技巧，听懂的最多的一次。</p>
<h3 id="P5290-十二省联考-2019-春节十二响"><a href="#P5290-十二省联考-2019-春节十二响" class="headerlink" title="P5290 十二省联考 2019 春节十二响"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5290">P5290 十二省联考 2019 春节十二响</a></h3><p>形式化题意：树上染色，链上的颜色不能重复，染一种颜色的代价是相同颜色的最大点权。最小化整棵树染色代价之和。</p>
<p>什么情况下是最优的：一个节点的所有儿子节点的子树的颜色集合应当尽量重合。</p>
<p>直接开个堆，然后做启发式合并即可。</p>
<blockquote>
<p> PS：有个想法来个老哥实现或者hack，我不会。</p>
<p>颜色数量上限是最长链，提出最长链，给最长链上的点权排序。</p>
<p>然后散链依次在最长链上二分插入一些位置。</p>
<p>可能是个大分讨，也非常的史，不如启发式合并优美。</p>
</blockquote>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 2e5+10;
int n,w[N],f[N];
ll ans=0;
vector&lt;int&gt; G[N],tmp;
priority_queue&lt;int&gt; q[N];
void merge(int x,int y)&#123;
    if(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);
    while(!q[y].empty())&#123;
        tmp.push_back(max(q[y].top(),q[x].top()));
        q[y].pop();q[x].pop();
    &#125;
    while(tmp.size())&#123;
        q[x].push(tmp.back());tmp.pop_back();
    &#125;
&#125;
void dfs(int u)&#123;
    for(int v:G[u])&#123;
        dfs(v);
        merge(u,v);
    &#125;
    q[u].push(w[u]);
&#125;
int main()&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;w[i];
    &#125;
    for(int i=2;i&lt;=n;i++)&#123;
        cin&gt;&gt;f[i];
        G[f[i]].push_back(i);
    &#125;
    dfs(1);
    while(!q[1].empty()) ans+=q[1].top(),q[1].pop();
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<h3 id="P3979-遥远的国度"><a href="#P3979-遥远的国度" class="headerlink" title="P3979 遥远的国度"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3979">P3979 遥远的国度</a></h3><p>画画图，类似换根的操作把树划分开，然后发现以 1 为定根就行。</p>
<p>需要刨出 rt 到 1 的点，用树剖然后操作一下就行。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 1e5+10;
int n,m,a[N],rt;
vector&lt;int&gt; G[N];
int fa[N],dfn[N],siz[N],hson[N],dfx,top[N],dep[N],rnk[N];
void dfs1(int u)&#123;
    dep[u]=dep[fa[u]]+1;siz[u]=1;
    for(int v:G[u])&#123;
        if(v==fa[u]) continue;
        fa[v]=u;
        dfs1(v);
        siz[u]+=siz[v];
        if(siz[hson[u]]&lt;siz[v]) hson[u]=v;
    &#125;
&#125;
void dfs2(int u,int tp)&#123;
    top[u]=tp;dfn[u]=++dfx,rnk[dfx]=u;
    if(!hson[u]) return ;
    dfs2(hson[u],tp);
    for(int v:G[u])&#123;
        if(v==hson[u] || v==fa[u]) continue;
        dfs2(v,v);
    &#125;
&#125;
struct SegTree&#123;
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define mid ((l+r)&gt;&gt;1)
    ll tr[N&lt;&lt;2],tag[N&lt;&lt;2];
    void pushup(int u)&#123;
        tr[u]=min(tr[ls],tr[rs]);
    &#125;
    void upd(int u,ll k)&#123;
        tr[u]=tag[u]=k;
    &#125;
    void build(int u,int l,int r)&#123;
        if(l==r)&#123;tr[u]=a[rnk[l]];return;&#125;
        build(ls,l,mid);build(rs,mid+1,r);
        pushup(u);
    &#125;
    void pushdown(int u)&#123;
        if(!tag[u]) return ;
        upd(ls,tag[u]);upd(rs,tag[u]);
        tag[u]=0;
    &#125;
    void modify(int u,int l,int r,int x,int y,ll k)&#123;
        if(l&gt;=x &amp;&amp; r&lt;=y)&#123;upd(u,k);return;&#125;
        pushdown(u);
        if(x&lt;=mid) modify(ls,l,mid,x,y,k);
        if(mid&lt;y) modify(rs,mid+1,r,x,y,k);
        pushup(u);
    &#125;
    ll query(int u,int l,int r,int x,int y)&#123;
        if(l&gt;=x &amp;&amp; r&lt;=y) return tr[u];
        pushdown(u);
        ll res=1e18;
        if(x&lt;=mid) res=min(res,query(ls,l,mid,x,y));
        if(mid&lt;y) res=min(res,query(rs,mid+1,r,x,y));
        return res;
    &#125;
#undef ls
#undef rs
#undef mid
&#125;Tr;
void modify(int x,int y,int k)&#123;
    while(top[x]!=top[y])&#123;
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);
        Tr.modify(1,1,n,dfn[top[x]],dfn[x],k);
        x=fa[top[x]];
    &#125;
    if(dfn[x]&gt;dfn[y]) swap(x,y);
    Tr.modify(1,1,n,dfn[x],dfn[y],k);
&#125;
int find(int x)&#123;
    if(x==rt) return -1;
    if(dfn[x]&gt;=dfn[rt] || dfn[x]+siz[x]-1 &lt; dfn[rt]) return 0;
    int u=rt;
    while(top[u]!=top[x])&#123;
        if(fa[top[u]]==x) return top[u];
        u=fa[top[u]];
    &#125;
    return hson[x];
&#125;
ll query(int x)&#123;
    int u=find(x);
    if(u==-1) return Tr.tr[1];
    else if(u==0) return Tr.query(1,1,n,dfn[x],dfn[x]+siz[x]-1);
    else&#123;
        ll ans=Tr.query(1,1,n,1,dfn[u]-1);
        if(dfn[u]+siz[u]-1!=n) ans=min(ans,Tr.query(1,1,n,dfn[u]+siz[u],n));
        return ans;
    &#125;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v;i&lt;n;i++)&#123;
        cin&gt;&gt;u&gt;&gt;v;
        G[u].push_back(v);G[v].push_back(u);
    &#125;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    cin&gt;&gt;rt;dfs1(rt);dfs2(rt,rt);
    Tr.build(1,1,n);
    for(int i=1,op,x;i&lt;=m;i++)&#123;
        cin&gt;&gt;op&gt;&gt;x;
        if(op==1)&#123;
            rt=x;
        &#125;else if(op==2)&#123;
            int y,v;cin&gt;&gt;y&gt;&gt;v;
            modify(x,y,v);
        &#125;else&#123;
            cout &lt;&lt; query(x) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="P7735-NOI2021-轻重边"><a href="#P7735-NOI2021-轻重边" class="headerlink" title="P7735 NOI2021 轻重边"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7735">P7735 NOI2021 轻重边</a></h3><p>史诗级史题，超级无敌难写。</p>
<p>首先题意转化：给点颜色覆盖，求相邻的点的相同颜色的数量。</p>
<p>然后就可以写了，发现一堆细节。然后就一直调调调吧，注意一下链的合并的左右顺序。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 1e5+10;
int T,n,m;
vector&lt;int&gt; G[N];
int dep[N],fa[N],dfn[N],dfx,top[N],siz[N],hson[N];
void dfs1(int u)&#123;
    dep[u]=dep[fa[u]]+1;
    siz[u]=1;
    for(int v:G[u])&#123;
        if(v==fa[u]) continue;
        fa[v]=u;
        dfs1(v);
        siz[u]+=siz[v];
        if(siz[hson[u]]&lt;siz[v]) hson[u]=v;
    &#125;
&#125;
void dfs2(int u,int tp)&#123;
    top[u]=tp;dfn[u]=++dfx;
    if(!hson[u]) return ;
    dfs2(hson[u],tp);
    for(int v:G[u])&#123;
        if(v==fa[u] || v==hson[u]) continue;
        dfs2(v,v);
    &#125;
&#125;
struct Tree&#123;
    int sum,lc,rc;
    Tree(int s=0,int l=0,int r=0):sum(s),lc(l),rc(r)&#123;&#125;
&#125;tr[N&lt;&lt;2];
struct SegTree&#123;
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define mid ((l+r)&gt;&gt;1)
    int tag[N&lt;&lt;2];
    void init()&#123;
        memset(tag,0,sizeof(tag));
        for(int i=0;i&lt;(N&lt;&lt;2);i++) tr[i]=Tree();
    &#125;
    void upd(int u,int k,int len)&#123;
        tr[u]=Tree(len,k,k);
        tag[u]=k;
    &#125;
    void pushdown(int u,int l,int r)&#123;
        if(!tag[u]) return;
        upd(ls,tag[u],mid-l);
        upd(rs,tag[u],r-mid-1);
        tag[u]=0;
    &#125;
    void modify(int u,int l,int r,int x,int y,int k)&#123;
        if(l&gt;=x &amp;&amp; r&lt;=y)&#123;
            upd(u,k,r-l);return;
        &#125;
        pushdown(u,l,r);
        if(x&lt;=mid) modify(ls,l,mid,x,y,k);
        if(mid&lt;y) modify(rs,mid+1,r,x,y,k);
        tr[u]=Tree(tr[ls].sum+tr[rs].sum+(tr[ls].rc==tr[rs].lc),tr[ls].lc,tr[rs].rc);
    &#125;
    Tree query(int u,int l,int r,int x,int y)&#123;
        if(l&gt;=x &amp;&amp; r&lt;=y)&#123;
            return tr[u];
        &#125;
        Tree r1=Tree(),r2=Tree();
        pushdown(u,l,r);
        if(x&lt;=mid) r1=query(ls,l,mid,x,y);
        if(mid&lt;y) r2=query(rs,mid+1,r,x,y);
        if(y&lt;=mid) return r1;
        else if(x&gt;mid) return r2;
        else return Tree(r1.sum+r2.sum+(r1.rc==r2.lc),r1.lc,r2.rc);
    &#125;
    void print()&#123;
        for(int i=1;i&lt;n&lt;&lt;2;i++)&#123;
            cout &lt;&lt; tr[i].lc &lt;&lt; &#39; &#39;;
        &#125;cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;Tr;
void init()&#123;
    memset(dep,0,sizeof(dep));
    memset(fa,0,sizeof(fa));
    memset(dfn,0,sizeof(dfn));
    memset(top,0,sizeof(top));
    memset(hson,0,sizeof(hson));
    memset(siz,0,sizeof(siz));
    dfx=0;
    for(int i=1;i&lt;N;i++) G[i].clear();
&#125;
void modify(int x,int y,int k)&#123;
    while(top[x]!=top[y])&#123;
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);
        Tr.modify(1,1,n,dfn[top[x]],dfn[x],k);
        x=fa[top[x]];
    &#125;
    if(dfn[x]&gt;dfn[y]) swap(x,y);
    Tr.modify(1,1,n,dfn[x],dfn[y],k);
&#125;
int query(int x,int y)&#123;
    bool f=0;
    Tree ans1=Tree(),ans2=Tree(),tmp=Tree();
    while(top[x]!=top[y])&#123;
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y),f=!f;
        tmp=Tr.query(1,1,n,dfn[top[x]],dfn[x]);
        if(f)&#123;
            ans2=Tree(tmp.sum+ans2.sum+(tmp.rc==ans2.lc),tmp.lc,ans2.rc);
        &#125;else&#123;
            ans1=Tree(ans1.sum+tmp.sum+(ans1.rc==tmp.rc),ans1.lc,tmp.lc);
        &#125;
        x=fa[top[x]];
    &#125;
    if(dep[x]&lt;dep[y]) swap(x,y),f=!f;
    tmp=Tr.query(1,1,n,dfn[y],dfn[x]);
    if(f)&#123;
        ans2=Tree(tmp.sum+ans2.sum+(tmp.rc==ans2.lc),tmp.lc,ans2.rc);
    &#125;else&#123;
        ans1=Tree(ans1.sum+tmp.sum+(ans1.rc==tmp.rc),ans1.lc,tmp.lc);
    &#125;
    return ans1.sum+ans2.sum+(ans1.rc==ans2.lc);
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;T;
    while(T--)&#123;
        cin&gt;&gt;n&gt;&gt;m;
        for(int i=1,u,v;i&lt;n;i++)&#123;
            cin&gt;&gt;u&gt;&gt;v;
            G[u].push_back(v);G[v].push_back(u);
        &#125;
        dfs1(1);dfs2(1,1);
        Tr.init();
        for(int i=1;i&lt;=n;i++)&#123;Tr.modify(1,1,n,dfn[i],dfn[i],-i);&#125;
        for(int i=1,op,a,b;i&lt;=m;i++)&#123;
            cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;
            if(op==1)&#123;
                modify(a,b,i);
            &#125;else&#123;
                cout &lt;&lt; query(a,b) &lt;&lt; &#39;\n&#39;;
            &#125;
        &#125;
        init();
    &#125;
    return 0;
&#125;
</code></pre>

            </div>
        
    </div>

    <!-- 毛玻璃悬浮目录区域 -->
    <aside class="toc-container">
        <div class="toc-header">
            <h3><i class="fas fa-list"></i> 文章目录</h3>
            <button class="toc-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="toc-content" id="toc-content"></div>
    </aside>

    <!-- 移动端目录按钮 -->
    <div class="toc-mobile-toggle">
        <i class="fas fa-list"></i>
    </div>

    
    
    <div id="comment">
        <div id="gitalk-container"></div>
    </div>
    
    
    
    
    
</div>

    

<!-- 引入悬浮目录资源 -->
<link rel="stylesheet" href="/css/toc.css">
<script src="/js/toc.js"></script>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 Tighnari&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tighnari
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
        <!-- �������� -->
<div id="desk-pet-container">
  <div class="tooltip">"Ciallo~!"</div>
  <div class="desk-pet"></div>
</div>
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    

<script>
    const gitalk = new Gitalk({
        clientID: "Ov23limqYY7vc8UqtOwE",
        clientSecret: "46550e05732da9bcac2486329b528d4382f83ac7",
        repo: "issue",
        owner: "Ti-ghnari",
        admin: "Ti-ghnari".split(","),
        language: "zh-CN",
        id: location.pathname,
        
    })
    gitalk.render("gitalk-container");
</script>




    
</body>
</html>
