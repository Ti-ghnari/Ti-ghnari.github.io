
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AC自动机学习笔记 | Tighnari&#39;s blog</title>
    <meta name="author" content="Tighnari" />
    <meta name="description" content="Welcome to my blog" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TIGHNARI&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TIGHNARI&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>AC自动机学习笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/25
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>第二次学习AC自动机与第三次学习KMP (●’◡’●)</p>
<p>&lt;--more–&gt;<br>字符串不可战胜</p>
<p>以后我将只使用 AC自动机，比 KMP 简单好多啊。</p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>利用 Trie 的结构 和 KMP 的思想构建 AC自动机。<br>注意：KMP的思想而不是思路或者代码</p>
<p>KMP的思想是失配后快速挪到下一个匹配位置。<br>所以我们在 AC自动机 上构建 fail 指针，也是这个作用，但是定义不一样。<br>KMP中 nxt 指的是最长的相同前后缀。<br>AC自动机中 fail 是所有模式串的前缀中匹配当前状态的最长后缀。<br>所以我们不能拿构建 nxt 的思路方法构建 fail。</p>
<h3 id="怎么匹配？"><a href="#怎么匹配？" class="headerlink" title="怎么匹配？"></a>怎么匹配？</h3><p>通过走 Trie 树，如果失配了就跳 fail 指针来快速的匹配。</p>
<h3 id="怎么构建-fail-指针？"><a href="#怎么构建-fail-指针？" class="headerlink" title="怎么构建 fail 指针？"></a>怎么构建 fail 指针？</h3><p>广搜，所以我们处理到当前节点时，深度小于当前节点的已被处理完。<br>然后先跳父亲的 fail ，然后跳 fail 的fail 。<br>直到跳到的某个点有当前状态的出边，然后就指向出边的节点。<br>偷一张 OI-Wiki 的图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/hq6pb1hl.png"><br>去看 6 节点的 fail 构建：<br>先跳到父亲节点 5 ，然后跳父亲的 fail 到 10 ，然后 10 没有 ‘s’ 这条出边，跳 10 的 fail 到 0，发现 0 有 ‘s’ 的出边，所以 6 的 fail 指向 7。<br>再偷一下 OI-Wiki 的代码：</p>
<pre><code class="language-cpp">void build() &#123;
  queue&lt;int&gt; q;
  for (int i = 0; i &lt; 26; i++)
    if (tr[0].son[i]) q.push(tr[0].son[i]);
  while (!q.empty()) &#123;
    int u = q.front();
    q.pop();
    for (int i = 0; i &lt; 26; i++) &#123;
      if (tr[u].son[i]) &#123;
        tr[tr[u].son[i]].fail = tr[tr[u].fail].son[i];
        q.push(tr[u].son[i]);
      &#125; else
        tr[u].son[i] = tr[tr[u].fail].son[i];
    &#125;
  &#125;
&#125;
</code></pre>
<p>代码中 else 部分通过修改字典树的形态，直接把当前点的 fail 的出边情况拉到当前点没有的出边上。<br>可以手模一下，也可以理解成路径压缩，原本是沿着 fail 跳上去，现在直接把 fail 拉下来了。</p>
<h3 id="怎么进行匹配？"><a href="#怎么进行匹配？" class="headerlink" title="怎么进行匹配？"></a>怎么进行匹配？</h3><p>从头遍历文本串的每一位，依次匹配，失配了就跳 fail 。<br>再偷一下 OI-Wiki 的代码：</p>
<pre><code class="language-cpp">int query(const char t[]) &#123;
  int u = 0, res = 0;
  for (int i = 1; t[i]; i++) &#123;
    u = tr[u].son[t[i] - &#39;a&#39;];
    for (int j = u; j &amp;&amp; tr[j].cnt != -1; j = tr[j].fail) &#123;
      res += tr[j].cnt, tr[j].cnt = -1;
    &#125;
  &#125;
  return res;
&#125;
</code></pre>
<h3 id="能否优化？"><a href="#能否优化？" class="headerlink" title="能否优化？"></a>能否优化？</h3><p>可以的，query 时一直跳 fail 太费时间了。<br>我们可以为找到的节点打上 tag，保留所有的 fail 边，最后做一个内向树拓扑求和即可。<br>再再再偷一下 OI-Wiki 的代码：</p>
<pre><code class="language-cpp">void query(const char t[]) &#123;
  int u = 0;
  for (int i = 1; t[i]; i++) &#123;
    u = tr[u].son[t[i] - &#39;a&#39;];
    tr[u].ans++;
  &#125;
&#125;

void topu() &#123;
  queue&lt;int&gt; q;
  for (int i = 0; i &lt;= tot; i++)
    if (tr[i].du == 0) q.push(i);
  while (!q.empty()) &#123;
    int u = q.front();
    q.pop();
    ans[tr[u].idx] = tr[u].ans;
    int v = tr[u].fail;
    tr[v].ans += tr[u].ans;
    if (!--tr[v].du) q.push(v);
  &#125;
&#125;
</code></pre>
<p>把代码拼起来就是<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5357">【模板】AC自动机</a><br>这里给一份封装好的结构体AC自动机，define 个 N 和 SIZE 即可食用：<br>N 是数据范围，SIZE 是字符集</p>
<details>
<summary>点击查看代码</summary>

<pre><code class="language-cpp">struct ACauto&#123;
	struct node&#123;
		int son[SIZE];
		int fail,end;
		void init()&#123;
			memset(son,0,sizeof(son));
			fail=end=0;
		&#125;
	&#125;tr[N];
	int tot=0;
	void init()&#123;
		tot=0;
		tr[0].init();
	&#125;
	void insert(string s)&#123;
		int u=0;
		for(char ch:s)&#123;
			int &amp;son=tr[u].son[ch-&#39;a&#39;];
			if(!son) son=++tot,tr[son].init();
			u=son;
		&#125;
		tr[u].end++;
	&#125;
	void build()&#123;
		queue&lt;int&gt; que;
		for(int i=0;i&lt;SIZE;i++)&#123;
			if(tr[0].son[i]) que.push(tr[0].son[i]);
		&#125;
		while(!que.empty())&#123;
			int u=que.front();
			que.pop();
			for(int i=0;i&lt;SIZE;i++)&#123;
				if(tr[u].son[i])&#123;
					tr[tr[u].son[i]].fail=tr[tr[u].fail].son[i];
					que.push(tr[u].son[i]);
				&#125;else&#123;
					tr[u].son[i]=tr[tr[u].fail].son[i];
				&#125;
			&#125;
		&#125;
	&#125;
&#125;AC;
</code></pre>
</details>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>还没做，咕咕咕</p>
<h3 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2444">病毒</a></h3><p>“可以，总司令” 有 60 分。</p>
<p>构造文本串使得所有模式串都未出现在文本串中。</p>
<p>多模式串首先考虑 AC自动机，构建后刻画成功情况：<br>保证不走到某一模式串末尾的情况下，能走出来一个环即可。<br>所以标记所有模式串的末尾，然后用 DFS 判环就行。</p>
<p>注意一点：当 fail 的点是某个模式串的末尾时，当前点也一定不行，手模一下即可。</p>
<details>
<summary>点击查看代码</summary>

<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define N 30010
using namespace std;
struct ACauto&#123;
	struct node&#123;
		int son[2];
		int fail;
		bool c;
		void init()&#123;
			memset(son,0,sizeof(son));
			fail=0;
		&#125;
	&#125;tr[N];
	int tot=0,ans[N],cnt;
	void init()&#123;
		tot=cnt=0;
		tr[0].init();
	&#125;
	void insert(string s)&#123;
		int u=0;
		for(char ch:s)&#123;
			int &amp;son=tr[u].son[ch-&#39;0&#39;];
			if(!son) son=++tot,tr[son].init();
			u=son;
		&#125;
		tr[u].c=1;
	&#125;
	void build()&#123;
		queue&lt;int&gt; que;
		for(int i=0;i&lt;2;i++)&#123;
			if(tr[0].son[i]) que.push(tr[0].son[i]);
		&#125;
		while(!que.empty())&#123;
			int u=que.front();
			que.pop();
			for(int i=0;i&lt;2;i++)&#123;
				if(tr[u].son[i])&#123;
					que.push(tr[u].son[i]);
					int v=tr[u].fail;
					tr[tr[u].son[i]].fail=tr[v].son[i];
					if(tr[tr[v].son[i]].c)&#123;
						tr[tr[u].son[i]].c=1;
					&#125;
				&#125;else&#123;
					tr[u].son[i]=tr[tr[u].fail].son[i];
				&#125;
			&#125;
		&#125;
	&#125;
&#125;AC;
int n;
bool vis[N],use[N];
void dfs(int u)&#123;
	vis[u]=1;
	for(int i=0;i&lt;2;i++)&#123;
		if(vis[AC.tr[u].son[i]])&#123;
			cout &lt;&lt; &quot;TAK&quot;;
			exit(0);
		&#125;else if(!AC.tr[AC.tr[u].son[i]].c &amp;&amp; !use[AC.tr[u].son[i]])&#123;
			use[AC.tr[u].son[i]]=1;
			dfs(AC.tr[u].son[i]);
		&#125;
	&#125;
	vis[u]=0;
&#125;
int main()&#123;
	cin&gt;&gt;n;
	AC.init();
	for(int i=1;i&lt;=n;i++)&#123;
		string s;cin&gt;&gt;s;
		AC.insert(s);
	&#125;
	AC.build();
	dfs(0);
	cout &lt;&lt; &quot;NIE&quot;;
	return 0;
&#125;
</code></pre>
</details>

<h3 id="阿狸的打字机"><a href="#阿狸的打字机" class="headerlink" title="阿狸的打字机"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2414">阿狸的打字机</a></h3><p>暴力很显然，模拟后直接建 AC 自动机，复杂度是高贵的 $O(m|\sum|)$。</p>
<p>然后首先要优化空间，因为每一次都存下来，最后总空间是 $O(n|\sum|)$ 的，也不能接受。<br>所以我们在 Trie 上额外存一个父亲节点，每次回退时相当于回到父亲的操作，打印时也新开一个标记统计一下末尾节点是第几个出现的字符串。</p>
<p>然后考虑优化时间，容易想到离线按 $y$ 排序，然后把所有相同的 $y$ 一次查完，统一累加。</p>
<p>然后继续想，我们做的是找 $y$ 能经过多少个 $x$，所以直接转化题意成 $x$ 能经过多少个 $y$，题目变成子树求和，dfn序中子树在连续的区间内，所以是区间查询，随便维护一下，可以树状数组或者前缀和。</p>
<p>每次重新 update&#x2F;重构 一遍的复杂度又劣了，所以我们 DFS 一遍这棵树，每次添加节点后，如果这个节点有 $y$ 的询问，就去 $x$ 上统计子树和，然后回溯的时候把点的贡献删了就行。所以要支持单点修改，选择树状数组。</p>
<p>那么本题就愉快的做完了（难点是将询问转化为子树求和与后续优化）</p>
<details>
<summary>点击查看代码</summary>

<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define N 100010
using namespace std;
string s;
struct Q&#123;
	int x,y,id,ans;
&#125;q[N];
bool cmp(Q a,Q b)&#123;
	return a.y&lt;b.y;
&#125;
int n,a[N],m,ql[N],qr[N];
int dfn[N],dfx,low[N],tot,ans[N];
vector&lt;int&gt; G[N];
struct BIT&#123;
	#define lowbit(i) i&amp;-i
	int t[N];
	void update(int x,int k)&#123;
		if(!x) return ;
		for(int i=x;i&lt;=dfx;i+=lowbit(i))&#123;
			t[i]+=k;
		&#125;
	&#125;
	int query(int x)&#123;
		int res=0;
		for(int i=x;i;i-=lowbit(i))&#123;
			res+=t[i];
		&#125;
		return res;
	&#125;
&#125;T;
struct node&#123;
	int son[26];
	int vis[26];
	int fail,fa;
	vector&lt;int&gt; id;
&#125;t[N];
void build()&#123;
	queue&lt;int&gt; que;
	for(int i=0;i&lt;26;i++)&#123;
		if(t[0].son[i]) que.push(t[0].son[i]);
	&#125;
	while(!que.empty())&#123;
		int u=que.front();que.pop();
		for(int i=0;i&lt;26;i++)&#123;
			if(t[u].son[i])&#123;
				t[t[u].son[i]].fail=t[t[u].fail].son[i];
				que.push(t[u].son[i]);
			&#125;else&#123;
				t[u].son[i]=t[t[u].fail].son[i];
			&#125;
		&#125;
	&#125;
&#125;
void dfs(int u)&#123;
	dfn[u]=++dfx;
	for(int v:G[u])&#123;
		dfs(v);
	&#125;
	low[u]=dfx;
&#125;
void dfs2(int u)&#123;
	T.update(dfn[u],1);
	if(t[u].id.size())&#123;
		for(int j=0;j&lt;(int)t[u].id.size();j++)
			for(int i=ql[t[u].id[j]];i&lt;=qr[t[u].id[j]];i++)&#123;
				q[i].ans=T.query(low[a[q[i].x]])-T.query(dfn[a[q[i].x]]-1);
			&#125;
	&#125;
	for(int i=0;i&lt;26;i++)&#123;
		if(t[u].vis[i])&#123;
			dfs2(t[u].vis[i]);
		&#125;
	&#125;
	T.update(dfn[u],-1);
&#125;
int main()&#123;
	cin&gt;&gt;s;
	int u=0;
	for(char ch:s)&#123;
		if(ch&lt;=&#39;z&#39; &amp;&amp; ch&gt;=&#39;a&#39;)&#123;
			int &amp;son=t[u].son[ch-&#39;a&#39;];
			if(!son) son=++tot,t[tot].fa=u;
			u=son;
		&#125;
		if(ch==&#39;B&#39;) u=t[u].fa;
		if(ch==&#39;P&#39;) &#123;a[++n]=u;t[u].id.push_back(n);&#125;
	&#125;
	for(int i=0;i&lt;=tot;i++)&#123;
		for(int j=0;j&lt;26;j++)&#123;
			t[i].vis[j]=t[i].son[j];
		&#125;
	&#125;
	build();
	for(int i=1;i&lt;=tot;i++)&#123;
		G[t[i].fail].push_back(i);
	&#125;
	dfs(0);
	cin&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)&#123;
		cin&gt;&gt;q[i].x&gt;&gt;q[i].y;
		q[i].id=i;
	&#125;
	sort(q+1,q+1+m,cmp);
	int pos=1;
	for(int i=1;i&lt;=m;i=pos)&#123;
		ql[q[i].y]=i;
		while(q[i].y==q[pos].y) pos++;
		qr[q[i].y]=pos-1;
	&#125;
	dfs2(0);
	for(int i=1;i&lt;=m;i++) ans[q[i].id]=q[i].ans;
	for(int i=1;i&lt;=m;i++) cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
	return 0;
&#125;
</code></pre>
</details>

<h3 id="Divljak"><a href="#Divljak" class="headerlink" title="Divljak"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5840">Divljak</a></h3><p>如果没有修改，就是板子题，fail 树上统计子树和就行，所以考虑修改。</p>
<p>肯定不能插入就重新 buildfail，时空双爆炸。</p>
<p>再读题发现询问的集合只有最开始给出的 $n$ 个字符串，所以对 S 做 AC自动机。<br>当我们拿字符串 P 在 AC自动机上走的时候，相当于枚举 P 的前缀，对应的节点 u 则是 P 的前缀匹配的最长后缀，然后跳 fail 过程经过的节点，都是 P 的子串。<br>所以 P 的贡献其实是 P 能到达的点集 $V&#x3D;{v_1,v_2…v_p}$ 到根节点的所有链的并集。<br>根据之前的一道题（寻宝游戏）可知，树上若干点组成的路径，是这几个点按 dfn 排序后，相邻两点的路径长度。<br>运用这个技巧，排序后就变成 链加 和 单点查 了。这个时候就可以大力树剖+线段树。<br>当然可以偷懒用树上差分转为 单点修 和 子树和 用树状数组维护一下。</p>
<details>
<summary>点击查看代码</summary>

<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N=1e5+10;
const int M=2e6+10;
vector&lt;int&gt; G[M];
struct acauto&#123;
	struct node&#123;
		int son[26];
		int fail,cnt;
	&#125;tr[M];
	int tot=1,en[N];
	void insert(const string &amp;s,int idx)&#123;
		int u=1;
		for(char ch:s)&#123;
			int &amp;son=tr[u].son[ch-&#39;a&#39;];
			if(!son) son=++tot;
			u=son;
		&#125;
		tr[u].cnt++;
		en[idx]=u;
	&#125;
	void build_fail()&#123;
		for(int i=0;i&lt;26;i++)&#123;
			tr[0].son[i]=1;
		&#125;
		queue&lt;int&gt; que;
		que.push(1);tr[1].fail=0;
		while(!que.empty())&#123;
			int u=que.front();que.pop();
			for(int i=0;i&lt;26;i++)&#123;
				if(tr[u].son[i])&#123;
					tr[tr[u].son[i]].fail=tr[tr[u].fail].son[i];
					que.push(tr[u].son[i]);
				&#125;else&#123;
					tr[u].son[i]=tr[tr[u].fail].son[i];
				&#125;
			&#125;
		&#125;
	&#125;
&#125;AC;
struct BIT&#123;
#define lowbit(i) i&amp;-i
	int tr[M];
	void update(int x,int k)&#123;
		if(!x) return ;
		for(int i=x;i&lt;=AC.tot;i+=lowbit(i))&#123;
			tr[i]+=k;
		&#125;
	&#125;
	int query(int x)&#123;
		int res=0;
		for(int i=x;i;i-=lowbit(i))&#123;
			res+=tr[i];
		&#125;
		return res;
	&#125;
&#125;T;
int dep[M],siz[M],hson[M],top[M],fa[M],dfn[M],dfx;
void dfs1(int u,int pa)&#123;
	dep[u]=dep[pa]+1;fa[u]=pa;
	siz[u]=1;
	for(int v:G[u])&#123;
		if(v==pa) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]&gt;siz[hson[u]]) hson[u]=v;
	&#125;
&#125;
void dfs2(int u,int tp)&#123;
	top[u]=tp;
	dfn[u]=++dfx;
	if(!hson[u]) return;
	dfs2(hson[u],tp);
	for(int v:G[u])&#123;
		if(v==fa[u] || v==hson[u]) continue;
		dfs2(v,v);
	&#125;
&#125;
int LCA(int x,int y)&#123;
	while(top[x]!=top[y])&#123;
		if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	&#125;
	return dep[x]&gt;dep[y] ? y : x;
&#125;
bool cmp(int a,int b)&#123;
	return dfn[a]&lt;dfn[b];
&#125;
int n,q,tmp[M],cnt;
string s;
int main()&#123;
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)&#123;
		cin&gt;&gt;s;
		AC.insert(s,i);
	&#125;
	AC.build_fail();
	for(int i=2;i&lt;=AC.tot;i++)&#123;
		G[AC.tr[i].fail].push_back(i);
	&#125;
	dfs1(1,0);dfs2(1,1);
	cin&gt;&gt;q;
	for(int i=1,op;i&lt;=q;i++)&#123;
		cin&gt;&gt;op;
		if(op==1)&#123;
			cin&gt;&gt;s;
			int u=1,cnt=0;
			for(char ch:s)&#123;
				u=AC.tr[u].son[ch-&#39;a&#39;];
				tmp[++cnt]=u;
			&#125;
			for(int i=1;i&lt;=cnt;i++)&#123;
				int a=tmp[i];
				T.update(dfn[a],1);
			&#125;
			for(int i=1;i&lt;cnt;i++)&#123;
				int a=tmp[i],b=tmp[i+1];
				T.update(dfn[LCA(a,b)],-1);
			&#125;
		&#125;else&#123;
			int x;
			cin&gt;&gt;x;
			int idx=AC.en[x];
			cout &lt;&lt; T.query(dfn[idx]+siz[idx]-1)-T.query(dfn[idx]-1) &lt;&lt; &#39;\n&#39;;
		&#125;
	&#125;
	return 0;
&#125;
</code></pre>
</details> 
    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 Tighnari&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tighnari
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
