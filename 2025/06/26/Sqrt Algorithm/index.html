
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Sqrt Algorithm | Tighnari&#39;s blog</title>
    <meta name="author" content="Tighnari" />
    <meta name="description" content="总有人间一两风，圆我十万八千梦" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.css" />





<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TIGHNARI&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
        <a href="/friends">
            <i class="fa-solid fa-link fa-fw"></i>
            <span>&ensp;Friend_Links</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TIGHNARI&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
                <a href="/friends">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-link fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Friend_Links</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Sqrt Algorithm</h1>
    </div>

    
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/26
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/study-notes/" style="color: #03a9f4">
                    study notes
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Data-Structure/" style="color: #ffa2c4">
                    Data Structure
                </a>
            </span>
            
        </span>
        
    </div>
    
    <!-- 文章内容区域 - 修复加密逻辑 -->
    <div class="article-content">
        
            <!-- 非加密内容直接显示 -->
            <div class="content" v-pre>
                <p>优雅的暴力啊！</p>
<span id="more"></span>

<h2 id="The-Begin"><a href="#The-Begin" class="headerlink" title="The Begin"></a>The Begin</h2><p>根号算法的优势在于好想好写，且支持维护更多的信息。</p>
<p>比如区间众数这种线段树维护不了的，而我们可以使用分块维护。</p>
<p>当然本篇文章所说的根号算法不只有分块，还有莫队，根号分治等一系列复杂度为 $\sqrt {n}$ 的算法。</p>
<p>本文肯定会有一个 Ynoi 的大分块的，只是时间问题。</p>
<p>Update on 2025.6.30：完结了，笔者真的写了 Ynoi 系列大分块中的一个。</p>
<h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><p>先从最简单的开始吧！</p>
<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>形如让我们计算：$\sum_{i&#x3D;1}^{n} \lfloor\frac{n}{i}\rfloor$ 这种式子，</p>
<p>我们发现，$\lfloor\frac{n}{i}\rfloor$ 在 $i$ 值不同时可能相同，而且是一段连续的区间。</p>
<p>所以我们考虑将这些地方一起计算。</p>
<p>具体地，枚举左端点 $l$，求出右端点 $r$，然后令左端点挪动到右端点 $r$ 上。</p>
<p>经过推导，我们得出了：</p>
<p>$$r&#x3D;\lfloor \frac{n}{\lfloor\frac{n}{l}\rfloor}\rfloor$$</p>
<p>直接代入递推计算即可。</p>
<h3 id="模板题：UVA11526-H-n"><a href="#模板题：UVA11526-H-n" class="headerlink" title="模板题：UVA11526 H(n)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA11526">模板题：UVA11526 H(n)</a></h3><p>套公式直接做即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/H(n).cpp">代码</a></p>
<h3 id="例题：模积和"><a href="#例题：模积和" class="headerlink" title="例题：模积和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2260">例题：模积和</a></h3><p>推式子题，原题让求的是$$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m (n \bmod i)(m\bmod j),i≠j$$</p>
<p>长得太丑了，而且 $i≠j$ 丑到实在不忍直视。假定 $n\ge m$ ，得到如下：</p>
<p>$$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m (n \bmod i)(m\bmod j)-\sum_{i&#x3D;1}^m (m \bmod i)(n\bmod i)$$</p>
<p>模数不好表达，考虑利用模数定义转化一下：</p>
<p>$$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m (n -i\times \lfloor\frac{n}{i}\rfloor)(m-j\times \lfloor\frac{m}{j}\rfloor) - \sum_{i&#x3D;1}^m (m -i\times \lfloor\frac{m}{i}\rfloor)(m-i\times\lfloor\frac{n}{i}\rfloor)$$</p>
<p>然后发现减号前面那一项比较特别，写成这样：</p>
<p>$$\sum_{i&#x3D;1}^{n}(n-i\times\lfloor\frac{n}{i}\rfloor) \times \sum_{j&#x3D;1}^{m}(m-j\times\lfloor\frac{m}{j}\rfloor)$$</p>
<p>然后给它拆开，得到：</p>
<p>$$(n^2- \sum_{i&#x3D;1}^{n}(i\times\lfloor\frac{n}{i}\rfloor))\times (m^2- \sum_{j&#x3D;1}^{m}(j\times\lfloor\frac{m}{j}\rfloor))$$</p>
<p>然后前面这一车就可以拿整除分块算了，后面这一车做类似变化，最终得到一个</p>
<p>$$(n^2- \sum_{i&#x3D;1}^{n}(i\times\lfloor\frac{n}{i}\rfloor))\times (m^2- \sum_{j&#x3D;1}^{m}(j\times\lfloor\frac{m}{j}\rfloor))- \sum_{i&#x3D;1}^{m}(m\times n- n\times i\times\lfloor\frac{m}{i}\rfloor-m\times i\times\lfloor\frac{n}{i}\rfloor+i^2\times\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor)$$</p>
<p>这坨式子，发现后面的也是整除分块，接着就是整除分块快速求：</p>
<p>$$\sum_{i&#x3D;1}^{n}i\times \lfloor\frac{n}{i}\rfloor$$</p>
<p>令 $l&#x3D;i$，通过整除分块计算方式，我们知道 $r&#x3D;\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor} \rfloor$，所以 $r-l+1$ 就等于 $\frac{r\times(r+1)}{2}-\frac{(l-1)\times (l)}{2}$（$1-&gt;l,r$的前缀和相减），然后后面就是 $\frac{n}{l}$ ，然后就可以写完了。</p>
<p>后面的 $i^2$ 有平方和公式 $\frac{n\times (n+1) \times (2\times n+1)}{6}$ 。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%A8%A1%E7%A7%AF%E5%92%8C.cpp">代码</a></p>
<h2 id="根号分治"><a href="#根号分治" class="headerlink" title="根号分治"></a>根号分治</h2><h3 id="算法简介-1"><a href="#算法简介-1" class="headerlink" title="算法简介"></a>算法简介</h3><p>根号分治是一种平衡复杂度的思想。</p>
<p>比如有一道题，我们可以 $O(n^2)$ 预处理，$O(1)$ 回答或者 不预处理，$O(n)$ 回答。 </p>
<p>这两种复杂度我们都不能接受。</p>
<p>我们可以预处理 $\sqrt n$ 范围的，然后做到 $O(\sqrt n)$ 预处理 ，$O(\sqrt n)$ 回答。</p>
<p>题目先【TBD】</p>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>根号算法的代表，提起根号第一个想到的肯定是我们优雅的分块了！</p>
<h3 id="算法简介-2"><a href="#算法简介-2" class="headerlink" title="算法简介"></a>算法简介</h3><p>分块是 重构 和 懒标记 的结合，对于修改，通常使用“散块暴力，整块一起”的方法。</p>
<p>分块的作用主要是 <strong>平衡复杂度</strong> 和 <strong>维护线段树</strong> 等无法维护的信息。</p>
<p>将序列分块后，令块长为 $B$ ，可以得到单步复杂度为 $O(\frac{n}{B}+B)$。</p>
<p>根据均值不等式可以得到 $B&#x3D;\sqrt n$ 时有最优复杂度 $O(\sqrt n)$。</p>
<p>接下来手把手教大家写分块模板题：</p>
<h3 id="【模板】线段树-1"><a href="#【模板】线段树-1" class="headerlink" title="【模板】线段树 1"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">【模板】线段树 1</a></h3><p><strong>分块的预处理</strong></p>
<p>分块预处理需要三个数组，$L_x , R_x , belong_i$ 分别表示，第 $x$ 块序列的左端点，右端点，原序列中的第  $i$ 个点属于哪一块。</p>
<p><strong>分块区间加法</strong></p>
<p>顺应上述的分块思想，对于整块的修改打上 tag ，对于散块就暴力修改。<del>可能还用到了一点点的标记永久化的思想？</del></p>
<p><strong>分块的区间查询</strong></p>
<p>区间操作都很类似，只要注意一下计算时是否需要加上 tag 就行。</p>
<p><strong>多种运算操作</strong></p>
<p>根线段树一样，定义一个合理的优先级就行。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%911.cpp">代码</a></p>
<h2 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h2><h3 id="算法简介-3"><a href="#算法简介-3" class="headerlink" title="算法简介"></a>算法简介</h3><p>最基本的分块，就是对原序列分成若干块。</p>
<h3 id="教主的魔法"><a href="#教主的魔法" class="headerlink" title="教主的魔法"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2801">教主的魔法</a></h3><p>说人话：支持区间加法，查询区间内大于等于 k 的数的个数。</p>
<p>对于每一块都排好序，然后散块直接做就行了，对于整块，去二分查找后加上 $R_i-x+1$ 即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95.cpp">代码</a></p>
<h3 id="由乃打扑克"><a href="#由乃打扑克" class="headerlink" title="由乃打扑克"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5356">由乃打扑克</a></h3><p>第一道 Ynoi 题！</p>
<p>思路继承教主的魔法，整块内排序，考虑怎么求得第 k 小值。</p>
<p>去二分这个第 k 小值，然后查这个值是否是第 k 小就行啦。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E7%94%B1%E4%B9%83%E6%89%93%E6%89%91%E5%85%8B.cpp">代码</a></p>
<h3 id="ycz的妹子"><a href="#ycz的妹子" class="headerlink" title="ycz的妹子"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4879">ycz的妹子</a></h3><p>一句话题意：</p>
<ol>
<li>单点修。</li>
<li>单点插入。</li>
<li>删除第 k 个值。</li>
<li>全局查询和。</li>
</ol>
<p>线段树写起来显然很累，无论是脑子累或者是手累。</p>
<p>但是分块不一样，直接分块，单点修和单点插入显然，删除第 k 个值记录块内多少个有意义的值，然后直接跳块找即可。</p>
<p>甚至能支持区间查询和！</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/ycz%E7%9A%84%E5%A6%B9%E5%AD%90.cpp">代码</a></p>
<h2 id="值域分块"><a href="#值域分块" class="headerlink" title="值域分块"></a>值域分块</h2><h3 id="算法简介-4"><a href="#算法简介-4" class="headerlink" title="算法简介"></a>算法简介</h3><p>如题，可以理解为权值分块</p>
<h3 id="等这场战争结束之后"><a href="#等这场战争结束之后" class="headerlink" title="等这场战争结束之后"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5064">等这场战争结束之后</a></h3><p>可撤销并查集+值域分块。</p>
<p>具体做法：离线建立版本树，离散化后值域分块维护每一块每个值出现次数，入树时进行修改或询问，出树时撤销修改。</p>
<p>然后就是 Ynoi 的经典卡常时刻，本题需要卡的是 20MB 的空间。</p>
<ol>
<li><p>值域分块数组可以用 short。</p>
</li>
<li><p>块长设大一点。</p>
</li>
<li><p>使用版本树，别写在线！</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E7%AD%89%E8%BF%99%E5%9C%BA%E6%88%98%E4%BA%89%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%90%8E.cpp">代码</a></p>
<h3 id="Violet-蒲公英"><a href="#Violet-蒲公英" class="headerlink" title="[Violet] 蒲公英"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4168">[Violet] 蒲公英</a></h3><p>自然的想到离散化值域分块，因为求众数，要求多少个相同数，所以考虑前缀和。</p>
<p>具体而言，维护两个分块，一个 $s_{i,j}$ 表示第 $i$ 个块内的每个数的个数前缀和（对于 $i$ 统计），一个 $f_{i,j}$ 表示第 $i$ 块与第 $j$ 块之间的众数。这两个数组可以预处理。</p>
<p>对于询问，我们将询问分成三部分：</p>
<p>$———l——bl———————br——r————$</p>
<p>其中 $l,r$ 表示询问区间，$bl,br$ 表示若干个整块。可能的众数集合是：<strong>整块</strong>内的众数，$l\to bl$ 之间的某数，$br\to r$ 之间的某数。</p>
<p>散块暴力，整块一起，询问区间不能被分为两块时暴力，那么我们就做完了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E8%92%B2%E5%85%AC%E8%8B%B1.cpp">代码</a></p>
<h3 id="TJOI2007-可爱的质数-x2F-【模板】BSGS"><a href="#TJOI2007-可爱的质数-x2F-【模板】BSGS" class="headerlink" title=" [TJOI2007] 可爱的质数&#x2F;【模板】BSGS"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3846"> [TJOI2007] 可爱的质数&#x2F;【模板】BSGS</a></h3><p>原式为：$a^l &#x3D; b \pmod p$，化为 $a^{Am-n} &#x3D; b \pmod p$，左右两侧同乘 $a^n$，式子变为：$a^{Am} &#x3D; ba^n \pmod p$</p>
<p>我们可以预处理出所有的 $b\times a^n \bmod p$ 存入 hash 中，再去计算 $a^{Am} \bmod p$ 然后去查 hash 表中的数是否存在相同的数。 </p>
<p>用 hash 的时间复杂度是 $O(\sqrt p)$ 。用 map 是 $O(\sqrt p \times \log p)$ </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91BSGS%E7%AE%97%E6%B3%95.cpp">代码</a></p>
<h3 id="多少个1？"><a href="#多少个1？" class="headerlink" title="多少个1？"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4884">多少个1？</a></h3><p>若干个 $1……1111 (N)$ 的形式，思考一下可以转化为 $\frac{10^n-1}{9}$ 的形式。</p>
<p>那么原题就变为求：</p>
<p>$$\frac{10^n-1}{9}&#x3D;k\pmod m$$</p>
<p>略微化简，得到如下式子：</p>
<p>$$10^n &#x3D; 9\times k +1 \pmod m$$</p>
<p>求最小整数 $n$ 满足上述式子，套BSGS板子。</p>
<p>中间需要开 __int128 ，或者使用快速乘。</p>
<p>原理是乘法分配律，可以试着推一把<del>（反正我没推）</del>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%A4%9A%E5%B0%91%E4%B8%AA%201%EF%BC%9F.cpp">代码</a></p>
<h2 id="时间轴分块"><a href="#时间轴分块" class="headerlink" title="时间轴分块"></a>时间轴分块</h2><h3 id="算法简介-5"><a href="#算法简介-5" class="headerlink" title="算法简介"></a>算法简介</h3><p>如题而言，对时间轴进行分块，逐个时间处理。</p>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3863">序列</a></h3><p>带修也可以离线！</p>
<p>新增一个时间轴，两个修改中间的询问都是一个时间点。</p>
<p>我们先考虑只有一个数怎么做。</p>
<p>发现是查询前缀大于等于自己的数有多少个。</p>
<p>所以我们需要做一个查询排名和单点加法。</p>
<p>接下来考虑怎么做多个数。</p>
<p>我们离线后差分，将区间修改转为单点加法和前缀和即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%BA%8F%E5%88%97.cpp">代码</a></p>
<p>等我写俩题【TBD】</p>
<h2 id="根号重构"><a href="#根号重构" class="headerlink" title="根号重构"></a>根号重构</h2><h3 id="算法简介-6"><a href="#算法简介-6" class="headerlink" title="算法简介"></a>算法简介</h3><p>平衡修改和询问的复杂度的一个方式吧，具体而言设一个阈值 B，当操作积压到 B 的时候再去处理。</p>
<h3 id="桥梁"><a href="#桥梁" class="headerlink" title="桥梁"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5443">桥梁</a></h3><p>观察题目可以发现，我们能想出两种暴力做法：</p>
<ol>
<li>暴力模拟所有操作，询问时搜索，是 $O(n^2)$ 的。</li>
<li>离线询问按降序排序，每次回答时重跑时间轴之前的操作，然后拿可撤销并查集维护连通性，也是 $O(n^2\log n)$ 的。</li>
</ol>
<p>发现这两种暴力从截然不同的角度出发，一个枚举边，一个枚举操作，所以我们使用分块将这两个均摊一下。</p>
<p>简单而言，定义一个阈值 $B$，当积压的操作达到 $B$ 的时候处理当前所有操作，同样使用可持久化并查集维护一下。</p>
<p>复杂度很好玩了，我们会把操作分成 $\frac{q}{B}$ 块，每块最多 $B$ 个</p>
<p>将 B 带入上面两个暴力的复杂度，得到最后式子是 $O(qB\log n + \frac{qm\log m}{B})$ ，$B$ 取个 $\sqrt {mlogn}$ 据说跑的飞快，但是我 $B$ 取了个附近的定值，也跑过了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%A1%A5%E6%A2%81.cpp">代码</a></p>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><h3 id="算法简介-7"><a href="#算法简介-7" class="headerlink" title="算法简介"></a>算法简介</h3><p>莫队是优雅的暴力，通过挪动左右指针来移动到下一个询问区间。</p>
<p>离线算法，不带修复杂度为 $O(n\sqrt n)$，带修能做到 $O(n^{\frac{5}{3}})$。</p>
<p>需要将询问排序：如果左端点在同一块内，右端点升序，否则左端点升序。</p>
<p>可以玄学优化，左端点在偶数块右端点升序，否则降序。</p>
<h3 id="小Z的袜子"><a href="#小Z的袜子" class="headerlink" title="小Z的袜子"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1494">小Z的袜子</a></h3><p>莫队模板题，排完序直接做就行了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90.cpp">代码</a></p>
<h3 id="国家集训队-数颜色-x2F-维护队列"><a href="#国家集训队-数颜色-x2F-维护队列" class="headerlink" title=" [国家集训队] 数颜色 &#x2F; 维护队列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1903"> [国家集训队] 数颜色 &#x2F; 维护队列</a></h3><p>带修莫队模板题。</p>
<p>在莫队基础上加一维时间轴，先按时间轴排序，如果是同一时间轴的则按上述莫队正常排序。</p>
<p>考虑时间变动的影响，然后去更新消除影响即可。</p>
<p>复杂度经证明取 $B&#x3D;n^{\frac{2}{3}}$ 最优，所以总体复杂度是 $O(n^{\frac{5}{3}})$</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%95%B0%E9%A2%9C%E8%89%B2.cpp">代码</a></p>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><p>穿插上述各种题目，可能莫队偏多，因为纯考分块的只有lxl大分块。</p>
<h3 id="Rmq-Problem-x2F-mex"><a href="#Rmq-Problem-x2F-mex" class="headerlink" title="Rmq Problem &#x2F; mex"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4137">Rmq Problem &#x2F; mex</a></h3><p>显然值域分块再加上前缀和就可以解决出现最小自然数的问题，配合莫队实现区间蠕动即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/P4137%20Rmq%20Problem.cpp">代码</a></p>
<p>如果你调半天调不出来，可以看看 while() 是不是写成了 if() 。<del>这玩意我看了半小时</del></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4396">作业</a></h3><p>会了上面那个，这个也就很显然了。</p>
<p>值域分块套上莫队，维护两个数组一个是所有和，一个是不同位置的和，写两个询问就好。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E4%BD%9C%E4%B8%9A.cpp">代码</a></p>
<h3 id="异或序列"><a href="#异或序列" class="headerlink" title="异或序列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4462">异或序列</a></h3><p>发现关键性质：给异或做前缀和，一段区间的异或值等于 $arr_r $ ^ $arr_{l-1}$ 然后莫队的移动我们就可以 $O(1)$ 了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%BC%82%E6%88%96%E5%BA%8F%E5%88%97.cpp">代码</a></p>
<h3 id="区间-range"><a href="#区间-range" class="headerlink" title="区间(range)"></a><a target="_blank" rel="noopener" href="https://sjzezoj.com/contest/410/problem/779">区间(range)</a></h3><p>不能做除法，O(1) 求数列中定长为 k 的所有区间的数的积模 P（P不保证为质数，不保证有逆元）。</p>
<p>首先会想到前缀积和后缀积，发现正常的前缀后缀积不能拼出来一个长度为 k 的区间。</p>
<p>考虑以 k 为块长分块，每块内做前缀后缀积，然后所有定长为 k 的恰好被分成两段（或者一整段）。</p>
<p>然后就可以直接写了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%8C%BA%E9%97%B4(range).cpp">代码</a></p>
<h3 id="小B的询问"><a href="#小B的询问" class="headerlink" title="小B的询问"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2709">小B的询问</a></h3><p>莫队的基础题，先把莫队扔上去。</p>
<p>考虑莫队维护区间平方和，难道我们要像线段树一样维护一个区间和，再维护一个区间平方和吗？</p>
<p>我都写莫队了，先把贡献删了，修改后再加回去就行。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE.cpp">代码</a></p>
<h2 id="The-End-去往那五彩斑斓的世界"><a href="#The-End-去往那五彩斑斓的世界" class="headerlink" title="The End 去往那五彩斑斓的世界"></a>The End 去往那<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4117">五彩斑斓的世界</a></h2><blockquote>
<p>故事终于来到最后，你打败了路上的所有小怪，精英怪，你来到了最终 boss 之前。</p>
<p>你攥紧了手中的宝具：[突刺贯穿的第二分块]。</p>
<p>仰望着漆黑的天空，轻抚着狂乱的风暴：</p>
<p>按照故事的剧本，打败最终 boss 之后，你就到了<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4117">五彩斑斓的世界</a>。</p>
<p>是的，是时候动身了，还有人在等着我们。</p>
</blockquote>
<p>fun fact：主播为了找一道能做的大分块找了一个多小时，最终还是回到了这道题</p>
<p>给定长度为 $n$ 的序列，$m$ 次操作</p>
<ol>
<li>把区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。</li>
<li>查询区间 $[l,r]$ 中 $x$ 的出现次数。</li>
</ol>
<p>$n\le 10^6 , m\le 5\times 10^5 ,0\le a_i,x \le 10^5+1$</p>
<p>拿到手第一刻很懵，相同的数可以并查集缩一起，查询时累加并查集大小就行。</p>
<p>但是我们似乎避不开要枚举值域，那我们就需要分析值域上的性质了。</p>
<p>假定我们现在序列中最大的数是 mx，减去的数是 x，n 为个数，m 为操作数，v 为值域。</p>
<p>分两种情况讨论：</p>
<ol>
<li><p>$2x\ge mx$, 那么全局最大值变为：$mx&#x3D;mx-x$</p>
</li>
<li><p>$2x &lt; mx$, 我们可以先令 $\le x$ 的数 +x ，那么全局就都比 x 大了，此时给全局打一个减法 tag，全局最大值依然变为：$mx&#x3D;mx-x$ 。</p>
</li>
</ol>
<p>发现全局最大值单调不增！</p>
<p>那么我们最大值上界是 $10^5$ 的，而操作却有 $5\times 10^5$ 次。</p>
<p>这是一个很好的均摊，我们直接枚举修改了哪些值即可。总计是 $O(v)$ 左右的。</p>
<p>那么复杂度有了保证，再想想实现的细节。</p>
<p>对于整块：<br>修改时直接遍历需要改的值，然后并查集合并。<br>询问时也是直接回答就行。<br>修改 $O(\sqrt n)$ ，询问 $O(1)$ 的。</p>
<p>对于散块：<br>修改时将所有值复原，再修改。<br>询问时也将所有值复原，再遍历。<br>都是 $O(\sqrt n)$ 的。</p>
<p>注意值域有 0，这玩意放进并查集里完蛋了，但是 0 不会变成负数，也不会有任何数变成 0。<br>所以可以直接预处理所有 0 的情况，做前缀和即可。</p>
<p>当然做完上述事情就已经可以 AC 另一道题了：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/896/problem/E">CF896E</a><br>fun fact：本题和 lxl 提出的珂朵莉树 是一场比赛的题。</p>
<p>本题 lxl 卡了线性空间，主播跟 lxl 斗智斗勇一中午终于调过。<br>fun fact：主播写的空间常数略大的线性空间也被卡飞了。</p>
<p>发现块与块之间相互独立，将询问离线下来，去每一个块里跑一遍，然后累加答案就行。</p>
<p>最终复杂度是：$O(m\sqrt n + n\sqrt v)$ 左右吧，不太会算。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C.cpp">代码</a></p>
<blockquote>
<p>来，出发吧，去选择那独一无二的明天</p>
</blockquote>
<p>除非 lxl 来讲课，不然这是主播最后一道 Ynoi 大分块系列题。</p>

            </div>
        
    </div>

    <!-- 毛玻璃悬浮目录区域 -->
    <aside class="toc-container">
        <div class="toc-header">
            <h3><i class="fas fa-list"></i> 文章目录</h3>
            <button class="toc-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="toc-content" id="toc-content"></div>
    </aside>

    <!-- 移动端目录按钮 -->
    <div class="toc-mobile-toggle">
        <i class="fas fa-list"></i>
    </div>

    
    
    <div id="comment">
        <div id="gitalk-container"></div>
    </div>
    
    
    
    
    
</div>

    

<!-- 引入悬浮目录资源 -->
<link rel="stylesheet" href="/css/toc.css">
<script src="/js/toc.js"></script>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 Tighnari&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tighnari
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
        <!-- �������� -->
<div id="desk-pet-container">
  <div class="tooltip">"Ciallo~!"</div>
  <div class="desk-pet"></div>
</div>
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    

<script>
    const gitalk = new Gitalk({
        clientID: "Ov23limqYY7vc8UqtOwE",
        clientSecret: "46550e05732da9bcac2486329b528d4382f83ac7",
        repo: "issue",
        owner: "Ti-ghnari",
        admin: "Ti-ghnari".split(","),
        language: "zh-CN",
        id: location.pathname,
        
    })
    gitalk.render("gitalk-container");
</script>




    
</body>
</html>
