
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Sqrt Algorithm | Tighnari&#39;s blog</title>
    <meta name="author" content="Tighnari" />
    <meta name="description" content="总有人间一两风，圆我十万八千梦" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TIGHNARI&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
        <a href="/friends">
            <i class="fa-solid fa-link fa-fw"></i>
            <span>&ensp;Friend_Links</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TIGHNARI&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
                <a href="/friends">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-link fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Friend_Links</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Sqrt Algorithm</h1>
    </div>

    
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/26
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/study-notes/" style="color: #ff7d73">
                    study notes
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Data-Structure/" style="color: #00bcd4">
                    Data Structure
                </a>
            </span>
            
        </span>
        
    </div>
    
    <!-- 文章内容区域 - 修复加密逻辑 -->
    <div class="article-content">
        
            <!-- 非加密内容直接显示 -->
            <div class="content" v-pre>
                <p>优雅的暴力啊！</p>
<span id="more"></span>

<h2 id="The-Begin"><a href="#The-Begin" class="headerlink" title="The Begin"></a>The Begin</h2><p>根号算法的优势在于好想好写，且支持维护更多的信息。</p>
<p>比如区间众数这种线段树维护不了的，而我们可以使用分块维护。</p>
<p>当然本篇文章所说的根号算法不只有分块，还有莫队，根号分治等一系列复杂度为 $\sqrt {n}$ 的算法。</p>
<p>本文肯定会有一个 Ynoi 的大分块的，只是时间问题。</p>
<p>Update on 2025.6.30：完结了，笔者真的写了 Ynoi 系列大分块中的一个。</p>
<h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><p>先从最简单的开始吧！</p>
<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>形如让我们计算：$\sum_{i&#x3D;1}^{n} \lfloor\frac{n}{i}\rfloor$ 这种式子，</p>
<p>我们发现，$\lfloor\frac{n}{i}\rfloor$ 在 $i$ 值不同时可能相同，而且是一段连续的区间。</p>
<p>所以我们考虑将这些地方一起计算。</p>
<p>具体地，枚举左端点 $l$，求出右端点 $r$，然后令左端点挪动到右端点 $r$ 上。</p>
<p>经过推导，我们得出了：</p>
<p>$$r&#x3D;\lfloor \frac{n}{\lfloor\frac{n}{l}\rfloor}\rfloor$$</p>
<p>直接代入递推计算即可。</p>
<h3 id="模板题：UVA11526-H-n"><a href="#模板题：UVA11526-H-n" class="headerlink" title="模板题：UVA11526 H(n)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA11526">模板题：UVA11526 H(n)</a></h3><p>套公式直接做即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/H(n).cpp">代码</a></p>
<h3 id="例题：模积和"><a href="#例题：模积和" class="headerlink" title="例题：模积和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2260">例题：模积和</a></h3><p>推式子题，原题让求的是$$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m (n \bmod i)(m\bmod j),i≠j$$</p>
<p>长得太丑了，而且 $i≠j​$ 丑到实在不忍直视。假定 $n\ge m​$ ，得到如下：</p>
<p>$$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m (n \bmod i)(m\bmod j)-\sum_{i&#x3D;1}^m (m \bmod i)(n\bmod i)​$$</p>
<p>模数不好表达，考虑利用模数定义转化一下：</p>
<p>$$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m (n -i\times \lfloor\frac{n}{i}\rfloor)(m-j\times \lfloor\frac{m}{j}\rfloor) - \sum_{i&#x3D;1}^m (m -i\times \lfloor\frac{m}{i}\rfloor)(n-i\times\lfloor\frac{n}{i}\rfloor)$$</p>
<p>然后发现减号前面那一项比较特别，写成这样：</p>
<p>$$\sum_{i&#x3D;1}^{n}(n-i\times\lfloor\frac{n}{i}\rfloor) \times \sum_{j&#x3D;1}^{m}(m-j\times\lfloor\frac{m}{j}\rfloor)$$</p>
<p>然后给它拆开，得到：</p>
<p>$$(n^2- \sum_{i&#x3D;1}^{n}(i\times\lfloor\frac{n}{i}\rfloor))\times (m^2- \sum_{j&#x3D;1}^{m}(j\times\lfloor\frac{m}{j}\rfloor))$$</p>
<p>然后前面这一车就可以拿整除分块算了，后面这一车做类似变化，最终得到一个</p>
<p>$$(n^2- \sum_{i&#x3D;1}^{n}(i\times\lfloor\frac{n}{i}\rfloor))\times (m^2- \sum_{j&#x3D;1}^{m}(j\times\lfloor\frac{m}{j}\rfloor))- \sum_{i&#x3D;1}^{m}(m\times n- n\times i\times\lfloor\frac{m}{i}\rfloor-m\times i\times\lfloor\frac{n}{i}\rfloor+i^2\times\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor)$$</p>
<p>这坨式子，发现后面的也是整除分块，接着就是整除分块快速求：</p>
<p>$$\sum_{i&#x3D;1}^{n}i\times \lfloor\frac{n}{i}\rfloor$$</p>
<p>令 $l&#x3D;i$，通过整除分块计算方式，我们知道 $r&#x3D;\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor} \rfloor$，所以 $r-l+1$ 就等于 $\frac{r\times(r+1)}{2}-\frac{(l-1)\times (l)}{2}$（$1-&gt;l,r$的前缀和相减），然后后面就是 $\frac{n}{l}$ ，然后就可以写完了。</p>
<p>后面的 $i^2$ 有平方和公式 $\frac{n\times (n+1) \times (2\times n+1)}{6}$ 。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%A8%A1%E7%A7%AF%E5%92%8C.cpp">代码</a></p>
<h2 id="根号分治"><a href="#根号分治" class="headerlink" title="根号分治"></a>根号分治</h2><h3 id="算法简介-1"><a href="#算法简介-1" class="headerlink" title="算法简介"></a>算法简介</h3><p>根号分治是一种平衡复杂度的思想。</p>
<p>比如有一道题，我们可以 $O(n^2)$ 预处理，$O(1)$ 回答或者 不预处理，$O(n)$ 回答。 </p>
<p>这两种复杂度我们都不能接受。</p>
<p>我们可以预处理 $\sqrt n$ 范围的，然后做到 $O(\sqrt n)$ 预处理 ，$O(\sqrt n)$ 回答。</p>
<hr>
<p>上面是我之前学艺不精狗叫，根号分治不仅仅有上面的形式。（现在也学艺不精）</p>
<h3 id="CF1806E-Tree-Master"><a href="#CF1806E-Tree-Master" class="headerlink" title="CF1806E Tree Master"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1806E">CF1806E Tree Master</a></h3><p>我们将树分层，并对每层的节点数分讨：</p>
<ul>
<li>如果当前层节点数大于 $\sqrt n$，这样的层数不超过 $ \sqrt n$ 个，我们直接进行搜索即可。</li>
<li>如果当前节点数小于 $ \sqrt  n​$，直接使用记忆化搜索即可。</li>
</ul>
<p>总之，直接记搜即可。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 1e5+10;
int n,m,a[N],fa[N],dep[N],sum[N],bel[N];
ll s[N];
ll f[N][500];
ll dfs(int x,int y)&#123;
    if(x==y) return s[x];
    if(sum[dep[x]]&lt;480)&#123;
        if(f[x][bel[y]]) return f[x][bel[y]];
        return f[x][bel[y]]=dfs(fa[x],fa[y])+1ll*a[x]*a[y];
    &#125;else return dfs(fa[x],fa[y])+1ll*a[x]*a[y];
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;
    for(int i=2;i&lt;=n;i++)&#123;cin&gt;&gt;fa[i];&#125;
    for(int i=1;i&lt;=n;i++)&#123;
        s[i]=s[fa[i]]+1ll*a[i]*a[i];
        dep[i]=dep[fa[i]]+1;
        bel[i]=++sum[dep[i]];
    &#125;
    for(int i=1,x,y;i&lt;=m;i++)&#123;
        cin&gt;&gt;x&gt;&gt;y;
        cout &lt;&lt; dfs(x,y) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="P3645-雅加达的摩天楼"><a href="#P3645-雅加达的摩天楼" class="headerlink" title="P3645 雅加达的摩天楼"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3645">P3645 雅加达的摩天楼</a></h3><p>想一个最暴力的暴力，建 $ 9\times 10^8$ 条边，然后直接暴力最短路。</p>
<p>发现我们其实根本用不到每一条边，所以尝试不存储状态直接 bfs，然后拿 bitset 表示状态，发现过了？</p>
<p>为什么是对的呢？不应该队列里扔了一堆状态然后暴空间吗？</p>
<p>我们对跳跃能力分讨：</p>
<ul>
<li>当 $p&gt; \sqrt n$ 时，对于这只 doge，只有 $ \sqrt n$ 个位置。总计 $m \sqrt n$ 个状态。</li>
<li>当 $p&lt;\sqrt n$ 时，对于每个点上状态，只有 $ \sqrt n$ 个不同的跳跃能力。总计 $n\sqrt n$ 个状态。</li>
</ul>
<p>所以总状态数是非常正确的，并不会 MLE&#x2F;TLE。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 3e4+10;
struct node&#123;
    int id,p,step;
&#125;;
queue&lt;node&gt; que;
bitset&lt;N&gt; vis[N];
vector&lt;int&gt; vec[N];
bool v[N];
int n,m,s,t;
void push(int i,int p,int step)&#123;
    if(!v[i])&#123;
        v[i]=1;
        for(int a:vec[i])&#123;
            if(!vis[i].test(a))&#123;
                vis[i].set(a);
                que.push(&#123;i,a,step+1&#125;);
            &#125;
        &#125;
    &#125;
    if(!vis[i].test(p))&#123;
        vis[i].set(p);
        que.push(&#123;i,p,step+1&#125;);
    &#125;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;m;i++)&#123;
        int b,p;
        cin&gt;&gt;b&gt;&gt;p;
        if(i==0) s=b;
        if(i==1) t=b;
        vec[b].push_back(p);
    &#125;
    if(s==t)&#123;cout &lt;&lt; 0;return 0;&#125;
    v[s]=1;
    for(int a:vec[s])&#123;
        if(!vis[s].test(a))&#123;
            vis[s].set(a);
            que.push(&#123;s,a,0&#125;);
        &#125;
    &#125;
    while(!que.empty())&#123;
        auto to=que.front();que.pop();
        if(to.id-to.p==t || to.id+to.p==t)&#123;
            cout &lt;&lt; to.step+1;
            return 0;
        &#125;
        if(to.id+to.p&lt;n)&#123;
            push(to.id+to.p,to.p,to.step);
        &#125;
        if(to.id-to.p&gt;=0)&#123;
            push(to.id-to.p,to.p,to.step);
        &#125;
    &#125;
    cout &lt;&lt; -1;
    return 0;
&#125;
</code></pre>
<h3 id="CF710F-String-Set-Queries"><a href="#CF710F-String-Set-Queries" class="headerlink" title="CF710F String Set Queries"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF710F">CF710F String Set Queries</a></h3><p>分治的标志：<strong>总量不超过……</strong></p>
<p>对字符串长度进行根号分治：</p>
<ul>
<li>长度小于 $ \sqrt n$ 的，上 Trie 树直接维护即可，询问直接暴力查询链和。</li>
<li>长度大于 $ \sqrt n$ 的，全扔去一边，然后用 KMP 维护，每次查询的时候重跑 KMP，然后暴力查询即可。</li>
</ul>
<p>Trie 树上的操作都是 $ \sqrt n$ 的，总计是 $O(n \sqrt n)$。而大于 $ \sqrt n$ 的仅有 $ \sqrt n$ 个，所以总计也是 $O(n \sqrt n)$ 的。</p>
<p>所以总计的复杂度是 $O(n \sqrt n)$ 。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N = 3e5+10;
int n;
struct Trie&#123;
    struct node&#123;
        int son[26];
        int cnt;
    &#125;tr[N];
    int tot=0;
    void insert(char *s,int val)&#123;
        int u=0;
        for(int i=0;s[i];i++)&#123;
            char ch=s[i];
            int &amp;son=tr[u].son[ch-&#39;a&#39;];
            if(!son) son=++tot;
            u=son;
        &#125;
        tr[u].cnt+=val;
    &#125;
    int query(char *s)&#123;
        int u=0,res=0;
        for(int i=0;s[i];i++)&#123;
            int c=s[i]-&#39;a&#39;;
            if(!tr[u].son[c]) break;
            u=tr[u].son[c];
            res+=tr[u].cnt;
        &#125;
        return res;
    &#125;
&#125;T;
struct KMP&#123;
    int nxt[N];
    void build(const string &amp;s,int len)&#123;
        memset(nxt,0,sizeof(nxt));
        int i=0,j=-1;nxt[0]=-1;
        while(i&lt;len)&#123;
            if(j==-1 || s[i]==s[j]) nxt[++i]=++j;
            else j=nxt[j];
        &#125;
    &#125;
    int query(string s,char *qry)&#123;
        int res=0;
        int lens=s.size(),len=strlen(qry);
        build(s,s.size());
        for(int i=0,j=0;i&lt;len;i++)&#123;
            while(j&gt;0 &amp;&amp; qry[i]!=s[j]) j=nxt[j];
            if(qry[i]==s[j]) j++;
            if(j==lens)&#123;
                res++;
                j=nxt[j];
            &#125;
        &#125;
        return res;
    &#125;
&#125;kmp;
string que[50];
char s[N];
int cnt,val[50];
int main()&#123;
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1,op;i&lt;=n;i++)&#123;
        scanf(&quot;%d%s&quot;,&amp;op,s);
        int len=strlen(s);
        if(op==1 || op==2)&#123;
            int v=(op==1 ? 1 : -1);
            if(len&lt;=1000)&#123;
                T.insert(s,v);
            &#125;else&#123;
                que[cnt]=string(s);
                val[cnt++]=v;
            &#125;
        &#125;else&#123;
            ll ans=0;
            for(int i=0;i&lt;len;i++)&#123;
                ans+=T.query(s+i);
            &#125;
            for(int i=0;i&lt;cnt;i++)&#123;
                if(que[i].length()&gt;len) continue;
                ans+=kmp.query(que[i],s)*val[i];
            &#125;
            printf(&quot;%lld\n&quot;,ans);
            fflush(stdout);
        &#125;
    &#125;
    
    return 0;
&#125;
</code></pre>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>根号算法的代表，提起根号第一个想到的肯定是我们优雅的分块了！</p>
<h3 id="算法简介-2"><a href="#算法简介-2" class="headerlink" title="算法简介"></a>算法简介</h3><p>分块是 重构 和 懒标记 的结合，对于修改，通常使用“散块暴力，整块一起”的方法。</p>
<p>分块的作用主要是 <strong>平衡复杂度</strong> 和 <strong>维护线段树</strong> 等无法维护的信息。</p>
<p>将序列分块后，令块长为 $B$ ，可以得到单步复杂度为 $O(\frac{n}{B}+B)$。</p>
<p>根据均值不等式可以得到 $B&#x3D;\sqrt n$ 时有最优复杂度 $O(\sqrt n)$。</p>
<p>接下来手把手教大家写分块模板题：</p>
<h3 id="【模板】线段树-1"><a href="#【模板】线段树-1" class="headerlink" title="【模板】线段树 1"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">【模板】线段树 1</a></h3><p><strong>分块的预处理</strong></p>
<p>分块预处理需要三个数组，$L_x , R_x , belong_i$ 分别表示，第 $x$ 块序列的左端点，右端点，原序列中的第  $i$ 个点属于哪一块。</p>
<p><strong>分块区间加法</strong></p>
<p>顺应上述的分块思想，对于整块的修改打上 tag ，对于散块就暴力修改。<del>可能还用到了一点点的标记永久化的思想？</del></p>
<p><strong>分块的区间查询</strong></p>
<p>区间操作都很类似，只要注意一下计算时是否需要加上 tag 就行。</p>
<p><strong>多种运算操作</strong></p>
<p>根线段树一样，定义一个合理的优先级就行。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%911.cpp">代码</a></p>
<h2 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h2><h3 id="算法简介-3"><a href="#算法简介-3" class="headerlink" title="算法简介"></a>算法简介</h3><p>最基本的分块，就是对原序列分成若干块。</p>
<h3 id="教主的魔法"><a href="#教主的魔法" class="headerlink" title="教主的魔法"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2801">教主的魔法</a></h3><p>说人话：支持区间加法，查询区间内大于等于 k 的数的个数。</p>
<p>对于每一块都排好序，然后散块直接做就行了，对于整块，去二分查找后加上 $R_i-x+1$ 即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95.cpp">代码</a></p>
<h3 id="由乃打扑克"><a href="#由乃打扑克" class="headerlink" title="由乃打扑克"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5356">由乃打扑克</a></h3><p>第一道 Ynoi 题！</p>
<p>思路继承教主的魔法，整块内排序，考虑怎么求得第 k 小值。</p>
<p>去二分这个第 k 小值，然后查这个值是否是第 k 小就行啦。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E7%94%B1%E4%B9%83%E6%89%93%E6%89%91%E5%85%8B.cpp">代码</a></p>
<h3 id="ycz的妹子"><a href="#ycz的妹子" class="headerlink" title="ycz的妹子"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4879">ycz的妹子</a></h3><p>一句话题意：</p>
<ol>
<li>单点修。</li>
<li>单点插入。</li>
<li>删除第 k 个值。</li>
<li>全局查询和。</li>
</ol>
<p>线段树写起来显然很累，无论是脑子累或者是手累。</p>
<p>但是分块不一样，直接分块，单点修和单点插入显然，删除第 k 个值记录块内多少个有意义的值，然后直接跳块找即可。</p>
<p>甚至能支持区间查询和！</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/ycz%E7%9A%84%E5%A6%B9%E5%AD%90.cpp">代码</a></p>
<h2 id="值域分块"><a href="#值域分块" class="headerlink" title="值域分块"></a>值域分块</h2><h3 id="算法简介-4"><a href="#算法简介-4" class="headerlink" title="算法简介"></a>算法简介</h3><p>如题，可以理解为权值分块</p>
<h3 id="等这场战争结束之后"><a href="#等这场战争结束之后" class="headerlink" title="等这场战争结束之后"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5064">等这场战争结束之后</a></h3><p>可撤销并查集+值域分块。</p>
<p>具体做法：离线建立版本树，离散化后值域分块维护每一块每个值出现次数，入树时进行修改或询问，出树时撤销修改。</p>
<p>然后就是 Ynoi 的经典卡常时刻，本题需要卡的是 20MB 的空间。</p>
<ol>
<li><p>值域分块数组可以用 short。</p>
</li>
<li><p>块长设大一点。</p>
</li>
<li><p>使用版本树，别写在线！</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E7%AD%89%E8%BF%99%E5%9C%BA%E6%88%98%E4%BA%89%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%90%8E.cpp">代码</a></p>
<h3 id="Violet-蒲公英"><a href="#Violet-蒲公英" class="headerlink" title="[Violet] 蒲公英"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4168">[Violet] 蒲公英</a></h3><p>自然的想到离散化值域分块，因为求众数，要求多少个相同数，所以考虑前缀和。</p>
<p>具体而言，维护两个分块，一个 $s_{i,j}$ 表示第 $i$ 个块内的每个数的个数前缀和（对于 $i$ 统计），一个 $f_{i,j}$ 表示第 $i$ 块与第 $j$ 块之间的众数。这两个数组可以预处理。</p>
<p>对于询问，我们将询问分成三部分：</p>
<p>$———l——bl———————br——r————$</p>
<p>其中 $l,r$ 表示询问区间，$bl,br$ 表示若干个整块。可能的众数集合是：<strong>整块</strong>内的众数，$l\to bl$ 之间的某数，$br\to r$ 之间的某数。</p>
<p>散块暴力，整块一起，询问区间不能被分为两块时暴力，那么我们就做完了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E8%92%B2%E5%85%AC%E8%8B%B1.cpp">代码</a></p>
<h3 id="TJOI2007-可爱的质数-x2F-【模板】BSGS"><a href="#TJOI2007-可爱的质数-x2F-【模板】BSGS" class="headerlink" title=" [TJOI2007] 可爱的质数&#x2F;【模板】BSGS"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3846"> [TJOI2007] 可爱的质数&#x2F;【模板】BSGS</a></h3><p>原式为：$a^l &#x3D; b \pmod p$，化为 $a^{Am-n} &#x3D; b \pmod p$，左右两侧同乘 $a^n$，式子变为：$a^{Am} &#x3D; ba^n \pmod p$</p>
<p>我们可以预处理出所有的 $b\times a^n \bmod p$ 存入 hash 中，再去计算 $a^{Am} \bmod p$ 然后去查 hash 表中的数是否存在相同的数。 </p>
<p>用 hash 的时间复杂度是 $O(\sqrt p)$ 。用 map 是 $O(\sqrt p \times \log p)$ </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91BSGS%E7%AE%97%E6%B3%95.cpp">代码</a></p>
<h3 id="多少个1？"><a href="#多少个1？" class="headerlink" title="多少个1？"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4884">多少个1？</a></h3><p>若干个 $1……1111 (N)$ 的形式，思考一下可以转化为 $\frac{10^n-1}{9}$ 的形式。</p>
<p>那么原题就变为求：</p>
<p>$$\frac{10^n-1}{9}&#x3D;k\pmod m$$</p>
<p>略微化简，得到如下式子：</p>
<p>$$10^n &#x3D; 9\times k +1 \pmod m$$</p>
<p>求最小整数 $n$ 满足上述式子，套BSGS板子。</p>
<p>中间需要开 __int128 ，或者使用快速乘。</p>
<p>原理是乘法分配律，可以试着推一把<del>（反正我没推）</del>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%A4%9A%E5%B0%91%E4%B8%AA%201%EF%BC%9F.cpp">代码</a></p>
<h2 id="时间轴分块"><a href="#时间轴分块" class="headerlink" title="时间轴分块"></a>时间轴分块</h2><h3 id="算法简介-5"><a href="#算法简介-5" class="headerlink" title="算法简介"></a>算法简介</h3><p>如题而言，对时间轴进行分块，逐个时间处理。</p>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3863">序列</a></h3><p>带修也可以离线！</p>
<p>新增一个时间轴，两个修改中间的询问都是一个时间点。</p>
<p>我们先考虑只有一个数怎么做。</p>
<p>发现是查询前缀大于等于自己的数有多少个。</p>
<p>所以我们需要做一个查询排名和单点加法。</p>
<p>接下来考虑怎么做多个数。</p>
<p>我们离线后差分，将区间修改转为单点加法和前缀和即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%BA%8F%E5%88%97.cpp">代码</a></p>
<p>等我写俩题【TBD】</p>
<h2 id="操作分块（阈值分块）"><a href="#操作分块（阈值分块）" class="headerlink" title="操作分块（阈值分块）"></a>操作分块（阈值分块）</h2><h3 id="算法简介-6"><a href="#算法简介-6" class="headerlink" title="算法简介"></a>算法简介</h3><p>平衡修改和询问的复杂度的一个方式吧，具体而言设一个阈值 B，当操作积压到 B 的时候再去处理。</p>
<h3 id="桥梁"><a href="#桥梁" class="headerlink" title="桥梁"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5443">桥梁</a></h3><p>观察题目可以发现，我们能想出两种暴力做法：</p>
<ol>
<li>暴力模拟所有操作，询问时搜索，是 $O(n^2)$ 的。</li>
<li>离线询问按降序排序，每次回答时重跑时间轴之前的操作，然后拿可撤销并查集维护连通性，也是 $O(n^2\log n)$ 的。</li>
</ol>
<p>发现这两种暴力从截然不同的角度出发，一个枚举边，一个枚举操作，所以我们使用分块将这两个均摊一下。</p>
<p>简单而言，定义一个阈值 $B$，当积压的操作达到 $B$ 的时候处理当前所有操作，同样使用可持久化并查集维护一下。</p>
<p>复杂度很好玩了，我们会把操作分成 $\frac{q}{B}$ 块，每块最多 $B$ 个</p>
<p>将 B 带入上面两个暴力的复杂度，得到最后式子是 $O(qB\log n + \frac{qm\log m}{B})$ ，$B$ 取个 $\sqrt {mlogn}$ 据说跑的飞快，但是我 $B$ 取了个附近的定值，也跑过了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%A1%A5%E6%A2%81.cpp">代码</a></p>
<h2 id="根号重构"><a href="#根号重构" class="headerlink" title="根号重构"></a>根号重构</h2><h3 id="算法简介-7"><a href="#算法简介-7" class="headerlink" title="算法简介"></a>算法简介</h3><p>你说得对，但是 单点修+维护抽象信息 为什么不想根号重构被修改的块。</p>
<p>难道你想写什么 奇技淫巧线段树 或者 大力 LCT 吗？</p>
<p>又或者什么 神奇转化+扫描线 吗？</p>
<h3 id="楼房重建"><a href="#楼房重建" class="headerlink" title="楼房重建"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4198">楼房重建</a></h3><p>题意：单点修+固定起点查上升子序列长度。</p>
<p>正解是单侧递归线段树或分块重构。</p>
<p>这种看起来很抽象的信息为什么不拿分块！</p>
<p>对于每一块，用 vector 存上升子序列，查询时二分查找即可。</p>
<p>对于修改，将所在块的 vector 清空后直接重构。</p>
<p>两个操作复杂度均为 $O(\sqrt n)$，显然可以轻松通过本题。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N=1e5+10;
int n,m,a[N],len,bel[N],s=2e9;
vector&lt;double&gt; vec[N];
void init()&#123;
    for(int i=1;i&lt;=n;i++)&#123;
        bel[i]=(i-1)/len+1;
    &#125;
&#125;
void modify(int x,int k)&#123;
    a[x]=k;
    double mx=0;
    vec[bel[x]].clear();
    for(int i=(bel[x]-1)*len+1;bel[i]==bel[x] &amp;&amp; i&lt;=n;i++)&#123;
        if(!a[i]) continue;
        double tmp=(double)a[i]/(1.0*i);
        if(tmp&gt;mx) vec[bel[x]].push_back(tmp),mx=tmp;
    &#125;
&#125;
int find(int x,double val)&#123;
    return vec[x].end()-upper_bound(vec[x].begin(),vec[x].end(),val);
&#125;
int query()&#123;
    int res=0;
    double mx=(double)a[s]/(1.0*s);
    for(int i=1;i&lt;=bel[n];i++)&#123;
        res+=find(i,mx);
        if(vec[i].empty()) continue;
        double tmp=(*(--vec[i].end()));
        if(mx&lt;tmp) mx=tmp;
    &#125;
    return res+1;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    len=sqrt(n*log(n));
    init();
    for(int i=1;i&lt;=m;i++)&#123;
        int x,k;
        cin&gt;&gt;x&gt;&gt;k;
        s=min(s,x);
        modify(x,k);
        cout &lt;&lt; query() &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="弹飞绵羊"><a href="#弹飞绵羊" class="headerlink" title="弹飞绵羊"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3203">弹飞绵羊</a></h3><p>这次你没法选了，不写 分块 你难道写 LCT 吗？</p>
<p>下文称 $i$ 到达的位置为 $to_i$</p>
<p>有个非常自然的暴力：</p>
<ul>
<li>询问时直接依次遍历模拟，然后得出答案。询问：$O(n)$ 修改：$O(1)$。</li>
<li>当然稍加思索，如果没有修改，答案就是一段 $to_i$ 的前缀和，可以预处理。询问：$O(1)$ 修改 $O(n)$。</li>
</ul>
<p>两个暴力都有了，符合分块平衡复杂度的必要条件了，那就分块呗。</p>
<p>把指向与 $i$ 一个块内的 $to_i$ 并列起来，然后做前缀和，查询时直接查询前缀和后跳到下一块。</p>
<p>可能上面说的有点抽象，可以看看代码。（这题还有助于加强对前缀和的理解欸）</p>
<p>复杂度分析：</p>
<ul>
<li>我们把每块内的 $to_i$ 并到一起，指向 $to_{R_i}$，所以查询最多遍历 $\sqrt n$ 个块。</li>
<li>修改直接重构一整块就行，最多 $\sqrt n$ 个数。</li>
</ul>
<p>所以复杂度是 $O(n\sqrt n)​$ 的。你 LCT 跑得过吗？！（跑过了我就去调块长）</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define B 500
using namespace std;
const int N = 2e5+10;
int n,m,a[N];
int to[N],bel[N],L[N],R[N],tot,cnt[N];
void init()&#123;
    tot=(n-1)/B+1;
    for(int i=1;i&lt;=n;i++)&#123;
        bel[i]=(i-1)/B+1;
    &#125;
    for(int i=1;i&lt;=tot;i++)&#123;
        L[i]=(i-1)*B+1;
        R[i]=min(i*B,n);
    &#125;
    for(int i=1;i&lt;=tot;i++)&#123;
        for(int j=R[i];j&gt;=L[i];j--)&#123;
            if(j+a[j]&lt;=R[i])&#123;
                cnt[j]+=cnt[j+a[j]]+1;
                to[j]=to[j+a[j]];
            &#125;else&#123;
                cnt[j]=1;
                to[j]=j+a[j];
            &#125;
        &#125;
    &#125;
&#125;
void modify(int x,int k)&#123;
    a[x]=k;
    for(int i=R[bel[x]];i&gt;=L[bel[x]];i--) cnt[i]=to[i]=0;
    for(int i=R[bel[x]];i&gt;=L[bel[x]];i--)&#123;
        if(i+a[i]&lt;=R[bel[x]])&#123;
            cnt[i]+=cnt[i+a[i]]+1;
            to[i]=to[i+a[i]];
        &#125;else&#123;
            cnt[i]=1;
            to[i]=i+a[i];
        &#125;
    &#125;
&#125;
int query(int x)&#123;
    int res=0;
    while(x&lt;=n)&#123;
        res+=cnt[x];
        x=to[x];
    &#125;
    return res;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;a[i];
    &#125;
    init();
    cin&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        int op;cin&gt;&gt;op;
        if(op==1)&#123;
            int x;cin&gt;&gt;x;x++;
            cout &lt;&lt; query(x) &lt;&lt; &#39;\n&#39;;
        &#125;else&#123;
            int x,y;cin&gt;&gt;x&gt;&gt;y;x++;
            modify(x,y);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><h3 id="算法简介-8"><a href="#算法简介-8" class="headerlink" title="算法简介"></a>算法简介</h3><p>莫队是优雅的暴力，通过挪动左右指针来移动到下一个询问区间。</p>
<p>离线算法，不带修复杂度为 $O(n\sqrt n)$，带修能做到 $O(n^{\frac{5}{3}})$。</p>
<p>需要将询问排序：如果左端点在同一块内，右端点升序，否则左端点升序。</p>
<p>可以玄学优化，左端点在偶数块右端点升序，否则降序。</p>
<h3 id="小Z的袜子"><a href="#小Z的袜子" class="headerlink" title="小Z的袜子"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1494">小Z的袜子</a></h3><p>莫队模板题，排完序直接做就行了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90.cpp">代码</a></p>
<h3 id="国家集训队-数颜色-x2F-维护队列"><a href="#国家集训队-数颜色-x2F-维护队列" class="headerlink" title=" [国家集训队] 数颜色 &#x2F; 维护队列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1903"> [国家集训队] 数颜色 &#x2F; 维护队列</a></h3><p>带修莫队模板题。</p>
<p>在莫队基础上加一维时间轴，先按时间轴排序，如果是同一时间轴的则按上述莫队正常排序。</p>
<p>考虑时间变动的影响，然后去更新消除影响即可。</p>
<p>复杂度经证明取 $B&#x3D;n^{\frac{2}{3}}$ 最优，所以总体复杂度是 $O(n^{\frac{5}{3}})$</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%95%B0%E9%A2%9C%E8%89%B2.cpp">代码</a></p>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><p>穿插上述各种题目，可能莫队偏多，因为纯考分块的只有lxl大分块。</p>
<h3 id="Rmq-Problem-x2F-mex"><a href="#Rmq-Problem-x2F-mex" class="headerlink" title="Rmq Problem &#x2F; mex"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4137">Rmq Problem &#x2F; mex</a></h3><p>显然值域分块再加上前缀和就可以解决出现最小自然数的问题，配合莫队实现区间蠕动即可。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/P4137%20Rmq%20Problem.cpp">代码</a></p>
<p>如果你调半天调不出来，可以看看 while() 是不是写成了 if() 。<del>这玩意我看了半小时</del></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4396">作业</a></h3><p>会了上面那个，这个也就很显然了。</p>
<p>值域分块套上莫队，维护两个数组一个是所有和，一个是不同位置的和，写两个询问就好。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E4%BD%9C%E4%B8%9A.cpp">代码</a></p>
<h3 id="异或序列"><a href="#异或序列" class="headerlink" title="异或序列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4462">异或序列</a></h3><p>发现关键性质：给异或做前缀和，一段区间的异或值等于 $arr_r $ ^ $arr_{l-1}$ 然后莫队的移动我们就可以 $O(1)$ 了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%BC%82%E6%88%96%E5%BA%8F%E5%88%97.cpp">代码</a></p>
<h3 id="区间-range"><a href="#区间-range" class="headerlink" title="区间(range)"></a><a target="_blank" rel="noopener" href="https://sjzezoj.com/contest/410/problem/779">区间(range)</a></h3><p>不能做除法，O(1) 求数列中定长为 k 的所有区间的数的积模 P（P不保证为质数，不保证有逆元）。</p>
<p>首先会想到前缀积和后缀积，发现正常的前缀后缀积不能拼出来一个长度为 k 的区间。</p>
<p>考虑以 k 为块长分块，每块内做前缀后缀积，然后所有定长为 k 的恰好被分成两段（或者一整段）。</p>
<p>然后就可以直接写了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%8C%BA%E9%97%B4(range).cpp">代码</a></p>
<h3 id="小B的询问"><a href="#小B的询问" class="headerlink" title="小B的询问"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2709">小B的询问</a></h3><p>莫队的基础题，先把莫队扔上去。</p>
<p>考虑莫队维护区间平方和，难道我们要像线段树一样维护一个区间和，再维护一个区间平方和吗？</p>
<p>我都写莫队了，先把贡献删了，修改后再加回去就行。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE.cpp">代码</a></p>
<h3 id="小清新人渣的本愿"><a href="#小清新人渣的本愿" class="headerlink" title="小清新人渣的本愿"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3674">小清新人渣的本愿</a></h3><p>看完这个题面，已经对日本轻小说产生刻板印象了，果咩。</p>
<p>莫队套 bitset 模板题。</p>
<p>这种抽象东西肯定要拿莫队维护，然后就上值域 bitset 维护。</p>
<p>加法就是平移，减法存一个 $N-x$ 的值，然后推两下式子就也可以变成平移。（此时有两个 bitset）</p>
<p>乘法就可以直接分解质因数，反正是 $\sqrt n$ 的。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define B 213
using namespace std;
const int N = 1e5+10;
const int M = 1e5;
bitset&lt;N+5&gt; c1,c2;
struct Q&#123;
    int op,l,r,x,id;
    bool operator &lt; (const Q &amp;a)const&#123;
        return (l/B==a.l/B) ? (l/B&amp;1) ? r&lt;a.r : r&gt;a.r : l/B&lt;a.l/B;
    &#125;
&#125;q[N];
int n,m,a[N],cnt[N];
bool ans[N];
void add(int x)&#123;
    if(cnt[a[x]]==0) c1[a[x]]=c2[M-a[x]]=1;
    cnt[a[x]]++;
&#125;
void del(int x)&#123;
    cnt[a[x]]--;
    if(cnt[a[x]]==0) c1[a[x]]=c2[M-a[x]]=0;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;q[i].op&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].x;q[i].id=i;
    &#125;
    sort(q+1,q+1+m);
    int l=1,r=0;
    for(int i=1;i&lt;=m;i++)&#123;
        while(l&gt;q[i].l) add(--l);
        while(r&lt;q[i].r) add(++r);
        while(l&lt;q[i].l) del(l++);
        while(r&gt;q[i].r) del(r--);
        if(q[i].op==1)&#123;
            if((c1 &amp; (c1&lt;&lt;q[i].x)).any())
                ans[q[i].id]=1;
        &#125;else if(q[i].op==2)&#123;
            if((c1 &amp; (c2&gt;&gt;(M-q[i].x))).any())
                ans[q[i].id]=1;
        &#125;else&#123;
            for(int j=1;j*j&lt;=q[i].x;j++)&#123;
                if(q[i].x%j==0)&#123;
                    if(c1[j]&amp;&amp;c1[q[i].x/j])&#123;
                        ans[q[i].id]=1;
                        break;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        cout &lt;&lt; (ans[i] ? &quot;hana&quot; : &quot;bi&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="曼哈顿交易"><a href="#曼哈顿交易" class="headerlink" title="曼哈顿交易"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3730">曼哈顿交易</a></h3><p>论莫队与值域分块的适配度：100% ！</p>
<p>虽然本题有奇技淫巧省去值域分块的技巧，但是没必要，复杂度上界不是这个。</p>
<p>对第 $i$ 种股票开一个桶计数，定义为 $cnt1_i$，再对 $cnt1_i$ 开个桶计数为 $cnt2_i$ 。</p>
<p>然后莫队维护是简单的，查询也是平凡的，就是简单的跳块然后找到所属块后暴力。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define B 345
using namespace std;
const int N = 1e5+10;
int n,m,a[N],b[N],len;
struct Q&#123;
    int l,r,k,id;
    bool operator &lt; (const Q &amp;a)const&#123;
        return l/B==a.l/B ? (l/B)&amp;1 ? r&lt;a.r : r&gt;a.r : l/B&lt;a.l/B;
    &#125;
    Q(int _l=0,int _r=0,int _k=0,int _id=0):l(_l),r(_r),k(_k),id(_id)&#123;&#125;
&#125;q[N];
int ans[N],l=1,r=0;
int bel[N],L[N],R[N],cnt[N],sum[N],tot,cnt2[N];
void init()&#123;
    tot=(N-10-1)/B+1;
    for(int i=1;i&lt;=N-10;i++)&#123;
        bel[i]=(i-1)/B+1;
    &#125;
    for(int i=1;i&lt;=tot;i++)&#123;
        L[i]=(i-1)*B+1;
        R[i]=min(i*B,N-10);
    &#125;
&#125;
void add(int x)&#123;
    sum[bel[cnt[x]]]--;
    cnt2[cnt[x]]--;
    cnt2[++cnt[x]]++;
    sum[bel[cnt[x]]]++;
&#125;
void del(int x)&#123;
    sum[bel[cnt[x]]]--;
    cnt2[cnt[x]]--;
    cnt2[--cnt[x]]++;
    sum[bel[cnt[x]]]++;
&#125;
int query(int k)&#123;
    int x;
    for(x=1;x&lt;=tot;x++)&#123;
        if(k-sum[x]&lt;=0) break;
        k-=sum[x];
    &#125;
    if(x==tot+1) return -1;
    for(int i=L[x];i&lt;=R[x];i++)&#123;
        if(k-cnt2[i]&lt;=0) return i;
        k-=cnt2[i];
    &#125;
    return -1;
&#125;
int main()&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    init();
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;a[i];b[i]=a[i];
    &#125;
    sort(b+1,b+1+n);len=unique(b+1,b+1+n)-b-1;
    for(int i=1;i&lt;=n;i++)&#123;a[i]=lower_bound(b+1,b+1+len,a[i])-b;&#125;
    for(int i=1,l,r,k;i&lt;=m;i++)&#123;
        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
        q[i]=Q(l,r,k,i);
    &#125;
    sort(q+1,q+1+m);
    for(int i=1;i&lt;=m;i++)&#123;
        while(l&gt;q[i].l) add(a[--l]);
        while(r&lt;q[i].r) add(a[++r]);
        while(l&lt;q[i].l) del(a[l++]);
        while(r&gt;q[i].r) del(a[r--]);
        ans[q[i].id]=query(q[i].k);
    &#125;
    for(int i=1;i&lt;=m;i++)&#123;
        cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="The-End-去往那五彩斑斓的世界"><a href="#The-End-去往那五彩斑斓的世界" class="headerlink" title="The End 去往那五彩斑斓的世界"></a>The End 去往那<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4117">五彩斑斓的世界</a></h2><blockquote>
<p>故事终于来到最后，你打败了路上的所有小怪，精英怪，你来到了最终 boss 之前。</p>
<p>你攥紧了手中的宝具：[突刺贯穿的第二分块]。</p>
<p>仰望着漆黑的天空，轻抚着狂乱的风暴：</p>
<p>按照故事的剧本，打败最终 boss 之后，你就到了<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4117">五彩斑斓的世界</a>。</p>
<p>是的，是时候动身了，还有人在等着我们。</p>
</blockquote>
<p>fun fact：主播为了找一道能做的大分块找了一个多小时，最终还是回到了这道题</p>
<p>给定长度为 $n$ 的序列，$m$ 次操作</p>
<ol>
<li>把区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。</li>
<li>查询区间 $[l,r]$ 中 $x$ 的出现次数。</li>
</ol>
<p>$n\le 10^6 , m\le 5\times 10^5 ,0\le a_i,x \le 10^5+1$</p>
<p>拿到手第一刻很懵，相同的数可以并查集缩一起，查询时累加并查集大小就行。</p>
<p>但是我们似乎避不开要枚举值域，那我们就需要分析值域上的性质了。</p>
<p>假定我们现在序列中最大的数是 mx，减去的数是 x，n 为个数，m 为操作数，v 为值域。</p>
<p>分两种情况讨论：</p>
<ol>
<li><p>$2x\ge mx$, 那么全局最大值变为：$mx&#x3D;mx-x$</p>
</li>
<li><p>$2x &lt; mx$, 我们可以先令 $\le x$ 的数 +x ，那么全局就都比 x 大了，此时给全局打一个减法 tag，全局最大值依然变为：$mx&#x3D;mx-x$ 。</p>
</li>
</ol>
<p>发现全局最大值单调不增！</p>
<p>那么我们最大值上界是 $10^5$ 的，而操作却有 $5\times 10^5$ 次。</p>
<p>这是一个很好的均摊，我们直接枚举修改了哪些值即可。总计是 $O(v)$ 左右的。</p>
<p>那么复杂度有了保证，再想想实现的细节。</p>
<p>对于整块：<br>修改时直接遍历需要改的值，然后并查集合并。<br>询问时也是直接回答就行。<br>修改 $O(\sqrt n)$ ，询问 $O(1)$ 的。</p>
<p>对于散块：<br>修改时将所有值复原，再修改。<br>询问时也将所有值复原，再遍历。<br>都是 $O(\sqrt n)$ 的。</p>
<p>注意值域有 0，这玩意放进并查集里完蛋了，但是 0 不会变成负数，也不会有任何数变成 0。<br>所以可以直接预处理所有 0 的情况，做前缀和即可。</p>
<p>当然做完上述事情就已经可以 AC 另一道题了：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/896/problem/E">CF896E</a><br>fun fact：本题和 lxl 提出的珂朵莉树 是一场比赛的题。</p>
<p>本题 lxl 卡了线性空间，主播跟 lxl 斗智斗勇一中午终于调过。<br>fun fact：主播写的空间常数略大的线性空间也被卡飞了。</p>
<p>发现块与块之间相互独立，将询问离线下来，去每一个块里跑一遍，然后累加答案就行。</p>
<p>最终复杂度是：$O(m\sqrt n + n\sqrt v)$ 左右吧，不太会算。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ti-ghnari/cpp.github.io/blob/main/%E5%8D%9A%E5%AE%A2%E7%94%A8%E4%BB%A3%E7%A0%81/%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C.cpp">代码</a></p>
<blockquote>
<p>来，出发吧，去选择那独一无二的明天</p>
</blockquote>
<p>除非 lxl 来讲课，不然这是主播最后一道 Ynoi 大分块系列题。</p>

            </div>
        
    </div>

    <!-- 毛玻璃悬浮目录区域 -->
    <aside class="toc-container">
        <div class="toc-header">
            <h3><i class="fas fa-list"></i> 文章目录</h3>
            <button class="toc-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="toc-content" id="toc-content"></div>
    </aside>

    <!-- 移动端目录按钮 -->
    <div class="toc-mobile-toggle">
        <i class="fas fa-list"></i>
    </div>

    
    
    
    
    
    
</div>

    

<!-- 引入悬浮目录资源 -->
<link rel="stylesheet" href="/css/toc.css">
<script src="/js/toc.js"></script>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 Tighnari&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tighnari
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
        <!-- �������� -->
<div id="desk-pet-container">
  <div class="tooltip">"Ciallo~!"</div>
  <div class="desk-pet"></div>
</div>
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
